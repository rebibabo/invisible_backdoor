<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:pos="http://www.srcML.org/srcML/position" revision="1.0.0" language="C" filename="dataset/ropgen/aug/1/25086.c" pos:tabs="8"><function pos:start="1:1" pos:end="319:1"><type pos:start="1:1" pos:end="1:10"><specifier pos:start="1:1" pos:end="1:6">static</specifier> <name pos:start="1:8" pos:end="1:10">int</name></type> <name pos:start="1:12" pos:end="1:17">decode</name><parameter_list pos:start="1:18" pos:end="1:85">(<parameter pos:start="1:19" pos:end="1:39"><decl pos:start="1:19" pos:end="1:39"><type pos:start="1:19" pos:end="1:39"><name pos:start="1:19" pos:end="1:32">AVCodecContext</name> <modifier pos:start="1:34" pos:end="1:34">*</modifier></type><name pos:start="1:35" pos:end="1:39">avctx</name></decl></parameter>, <parameter pos:start="1:42" pos:end="1:51"><decl pos:start="1:42" pos:end="1:51"><type pos:start="1:42" pos:end="1:51"><name pos:start="1:42" pos:end="1:45">void</name> <modifier pos:start="1:47" pos:end="1:47">*</modifier></type><name pos:start="1:48" pos:end="1:51">data</name></decl></parameter>, <parameter pos:start="1:54" pos:end="1:67"><decl pos:start="1:54" pos:end="1:67"><type pos:start="1:54" pos:end="1:67"><name pos:start="1:54" pos:end="1:56">int</name> <modifier pos:start="1:58" pos:end="1:58">*</modifier></type><name pos:start="1:59" pos:end="1:67">data_size</name></decl></parameter>, <parameter pos:start="1:70" pos:end="1:84"><decl pos:start="1:70" pos:end="1:84"><type pos:start="1:70" pos:end="1:84"><name pos:start="1:70" pos:end="1:77">AVPacket</name> <modifier pos:start="1:79" pos:end="1:79">*</modifier></type><name pos:start="1:80" pos:end="1:84">avpkt</name></decl></parameter>)</parameter_list>

<block pos:start="3:1" pos:end="319:1">{<block_content pos:start="5:5" pos:end="317:15">

    <decl_stmt pos:start="5:5" pos:end="5:18"><decl pos:start="5:5" pos:end="5:17"><type pos:start="5:5" pos:end="5:13"><name pos:start="5:5" pos:end="5:13">BC_STATUS</name></type> <name pos:start="5:15" pos:end="5:17">ret</name></decl>;</decl_stmt>

    <decl_stmt pos:start="7:5" pos:end="7:33"><decl pos:start="7:5" pos:end="7:32"><type pos:start="7:5" pos:end="7:17"><name pos:start="7:5" pos:end="7:17">BC_DTS_STATUS</name></type> <name pos:start="7:19" pos:end="7:32">decoder_status</name></decl>;</decl_stmt>

    <decl_stmt pos:start="9:5" pos:end="9:20"><decl pos:start="9:5" pos:end="9:19"><type pos:start="9:5" pos:end="9:11"><name pos:start="9:5" pos:end="9:11">CopyRet</name></type> <name pos:start="9:13" pos:end="9:19">rec_ret</name></decl>;</decl_stmt>

    <decl_stmt pos:start="11:5" pos:end="11:42"><decl pos:start="11:5" pos:end="11:41"><type pos:start="11:5" pos:end="11:16"><name pos:start="11:5" pos:end="11:14">CHDContext</name> <modifier pos:start="11:16" pos:end="11:16">*</modifier></type><name pos:start="11:17" pos:end="11:20">priv</name>   <init pos:start="11:24" pos:end="11:41">= <expr pos:start="11:26" pos:end="11:41"><name pos:start="11:26" pos:end="11:41"><name pos:start="11:26" pos:end="11:30">avctx</name><operator pos:start="11:31" pos:end="11:32">-&gt;</operator><name pos:start="11:33" pos:end="11:41">priv_data</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="13:5" pos:end="13:35"><decl pos:start="13:5" pos:end="13:34"><type pos:start="13:5" pos:end="13:10"><name pos:start="13:5" pos:end="13:10">HANDLE</name></type> <name pos:start="13:12" pos:end="13:14">dev</name>         <init pos:start="13:24" pos:end="13:34">= <expr pos:start="13:26" pos:end="13:34"><name pos:start="13:26" pos:end="13:34"><name pos:start="13:26" pos:end="13:29">priv</name><operator pos:start="13:30" pos:end="13:31">-&gt;</operator><name pos:start="13:32" pos:end="13:34">dev</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="15:5" pos:end="15:37"><decl pos:start="15:5" pos:end="15:36"><type pos:start="15:5" pos:end="15:7"><name pos:start="15:5" pos:end="15:7">int</name></type> <name pos:start="15:9" pos:end="15:11">len</name>            <init pos:start="15:24" pos:end="15:36">= <expr pos:start="15:26" pos:end="15:36"><name pos:start="15:26" pos:end="15:36"><name pos:start="15:26" pos:end="15:30">avpkt</name><operator pos:start="15:31" pos:end="15:32">-&gt;</operator><name pos:start="15:33" pos:end="15:36">size</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="17:5" pos:end="17:27"><decl pos:start="17:5" pos:end="17:26"><type pos:start="17:5" pos:end="17:11"><name pos:start="17:5" pos:end="17:11">uint8_t</name></type> <name pos:start="17:13" pos:end="17:20">pic_type</name>   <init pos:start="17:24" pos:end="17:26">= <expr pos:start="17:26" pos:end="17:26"><literal type="number" pos:start="17:26" pos:end="17:26">0</literal></expr></init></decl>;</decl_stmt>



    <expr_stmt pos:start="21:5" pos:end="21:63"><expr pos:start="21:5" pos:end="21:62"><call pos:start="21:5" pos:end="21:62"><name pos:start="21:5" pos:end="21:10">av_log</name><argument_list pos:start="21:11" pos:end="21:62">(<argument pos:start="21:12" pos:end="21:16"><expr pos:start="21:12" pos:end="21:16"><name pos:start="21:12" pos:end="21:16">avctx</name></expr></argument>, <argument pos:start="21:19" pos:end="21:32"><expr pos:start="21:19" pos:end="21:32"><name pos:start="21:19" pos:end="21:32">AV_LOG_VERBOSE</name></expr></argument>, <argument pos:start="21:35" pos:end="21:61"><expr pos:start="21:35" pos:end="21:61"><literal type="string" pos:start="21:35" pos:end="21:61">"CrystalHD: decode_frame\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



    <if_stmt pos:start="25:5" pos:end="129:5"><if pos:start="25:5" pos:end="125:5">if <condition pos:start="25:8" pos:end="25:12">(<expr pos:start="25:9" pos:end="25:11"><name pos:start="25:9" pos:end="25:11">len</name></expr>)</condition> <block pos:start="25:14" pos:end="125:5">{<block_content pos:start="27:9" pos:end="123:9">

        <decl_stmt pos:start="27:9" pos:end="27:54"><decl pos:start="27:9" pos:end="27:53"><type pos:start="27:9" pos:end="27:15"><name pos:start="27:9" pos:end="27:15">int32_t</name></type> <name pos:start="27:17" pos:end="27:23">tx_free</name> <init pos:start="27:25" pos:end="27:53">= <expr pos:start="27:27" pos:end="27:53"><operator pos:start="27:27" pos:end="27:27">(</operator><name pos:start="27:28" pos:end="27:34">int32_t</name><operator pos:start="27:35" pos:end="27:35">)</operator><call pos:start="27:36" pos:end="27:53"><name pos:start="27:36" pos:end="27:48">DtsTxFreeSize</name><argument_list pos:start="27:49" pos:end="27:53">(<argument pos:start="27:50" pos:end="27:52"><expr pos:start="27:50" pos:end="27:52"><name pos:start="27:50" pos:end="27:52">dev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



        <if_stmt pos:start="31:9" pos:end="57:9"><if pos:start="31:9" pos:end="57:9">if <condition pos:start="31:12" pos:end="31:25">(<expr pos:start="31:13" pos:end="31:24"><name pos:start="31:13" pos:end="31:24"><name pos:start="31:13" pos:end="31:16">priv</name><operator pos:start="31:17" pos:end="31:18">-&gt;</operator><name pos:start="31:19" pos:end="31:24">parser</name></name></expr>)</condition> <block pos:start="31:27" pos:end="57:9">{<block_content pos:start="33:13" pos:end="55:46">

            <decl_stmt pos:start="33:13" pos:end="33:26"><decl pos:start="33:13" pos:end="33:25"><type pos:start="33:13" pos:end="33:21"><name pos:start="33:13" pos:end="33:19">uint8_t</name> <modifier pos:start="33:21" pos:end="33:21">*</modifier></type><name pos:start="33:22" pos:end="33:25">pout</name></decl>;</decl_stmt>

            <decl_stmt pos:start="35:13" pos:end="35:28"><decl pos:start="35:13" pos:end="35:27"><type pos:start="35:13" pos:end="35:15"><name pos:start="35:13" pos:end="35:15">int</name></type> <name pos:start="35:17" pos:end="35:21">psize</name> <init pos:start="35:23" pos:end="35:27">= <expr pos:start="35:25" pos:end="35:27"><name pos:start="35:25" pos:end="35:27">len</name></expr></init></decl>;</decl_stmt>

            <decl_stmt pos:start="37:13" pos:end="37:53"><decl pos:start="37:13" pos:end="37:52"><type pos:start="37:13" pos:end="37:25"><name pos:start="37:13" pos:end="37:23">H264Context</name> <modifier pos:start="37:25" pos:end="37:25">*</modifier></type><name pos:start="37:26" pos:end="37:26">h</name> <init pos:start="37:28" pos:end="37:52">= <expr pos:start="37:30" pos:end="37:52"><name pos:start="37:30" pos:end="37:52"><name pos:start="37:30" pos:end="37:33">priv</name><operator pos:start="37:34" pos:end="37:35">-&gt;</operator><name pos:start="37:36" pos:end="37:41">parser</name><operator pos:start="37:42" pos:end="37:43">-&gt;</operator><name pos:start="37:44" pos:end="37:52">priv_data</name></name></expr></init></decl>;</decl_stmt>



            <while pos:start="41:13" pos:end="47:69">while <condition pos:start="41:19" pos:end="41:25">(<expr pos:start="41:20" pos:end="41:24"><name pos:start="41:20" pos:end="41:24">psize</name></expr>)</condition><block type="pseudo" pos:start="43:17" pos:end="47:69"><block_content pos:start="43:17" pos:end="47:69">

                <expr_stmt pos:start="43:17" pos:end="47:69"><expr pos:start="43:17" pos:end="47:68"><name pos:start="43:17" pos:end="43:19">ret</name> <operator pos:start="43:21" pos:end="43:21">=</operator> <call pos:start="43:23" pos:end="47:68"><name pos:start="43:23" pos:end="43:38">av_parser_parse2</name><argument_list pos:start="43:39" pos:end="47:68">(<argument pos:start="43:40" pos:end="43:51"><expr pos:start="43:40" pos:end="43:51"><name pos:start="43:40" pos:end="43:51"><name pos:start="43:40" pos:end="43:43">priv</name><operator pos:start="43:44" pos:end="43:45">-&gt;</operator><name pos:start="43:46" pos:end="43:51">parser</name></name></expr></argument>, <argument pos:start="43:54" pos:end="43:58"><expr pos:start="43:54" pos:end="43:58"><name pos:start="43:54" pos:end="43:58">avctx</name></expr></argument>, <argument pos:start="43:61" pos:end="43:65"><expr pos:start="43:61" pos:end="43:65"><operator pos:start="43:61" pos:end="43:61">&amp;</operator><name pos:start="43:62" pos:end="43:65">pout</name></expr></argument>, <argument pos:start="43:68" pos:end="43:73"><expr pos:start="43:68" pos:end="43:73"><operator pos:start="43:68" pos:end="43:68">&amp;</operator><name pos:start="43:69" pos:end="43:73">psize</name></expr></argument>,

                                       <argument pos:start="45:40" pos:end="45:50"><expr pos:start="45:40" pos:end="45:50"><name pos:start="45:40" pos:end="45:50"><name pos:start="45:40" pos:end="45:44">avpkt</name><operator pos:start="45:45" pos:end="45:46">-&gt;</operator><name pos:start="45:47" pos:end="45:50">data</name></name></expr></argument>, <argument pos:start="45:53" pos:end="45:55"><expr pos:start="45:53" pos:end="45:55"><name pos:start="45:53" pos:end="45:55">len</name></expr></argument>, <argument pos:start="45:58" pos:end="45:72"><expr pos:start="45:58" pos:end="45:72"><name pos:start="45:58" pos:end="45:72"><name pos:start="45:58" pos:end="45:62">avctx</name><operator pos:start="45:63" pos:end="45:64">-&gt;</operator><name pos:start="45:65" pos:end="45:67">pkt</name><operator pos:start="45:68" pos:end="45:69">-&gt;</operator><name pos:start="45:70" pos:end="45:72">pts</name></name></expr></argument>,

                                       <argument pos:start="47:40" pos:end="47:54"><expr pos:start="47:40" pos:end="47:54"><name pos:start="47:40" pos:end="47:54"><name pos:start="47:40" pos:end="47:44">avctx</name><operator pos:start="47:45" pos:end="47:46">-&gt;</operator><name pos:start="47:47" pos:end="47:49">pkt</name><operator pos:start="47:50" pos:end="47:51">-&gt;</operator><name pos:start="47:52" pos:end="47:54">dts</name></name></expr></argument>, <argument pos:start="47:57" pos:end="47:67"><expr pos:start="47:57" pos:end="47:67"><name pos:start="47:57" pos:end="47:59">len</name> <operator pos:start="47:61" pos:end="47:61">-</operator> <name pos:start="47:63" pos:end="47:67">psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <expr_stmt pos:start="49:13" pos:end="53:43"><expr pos:start="49:13" pos:end="53:42"><call pos:start="49:13" pos:end="53:42"><name pos:start="49:13" pos:end="49:18">av_log</name><argument_list pos:start="49:19" pos:end="53:42">(<argument pos:start="49:20" pos:end="49:24"><expr pos:start="49:20" pos:end="49:24"><name pos:start="49:20" pos:end="49:24">avctx</name></expr></argument>, <argument pos:start="49:27" pos:end="49:40"><expr pos:start="49:27" pos:end="49:40"><name pos:start="49:27" pos:end="49:40">AV_LOG_VERBOSE</name></expr></argument>,

                   <argument pos:start="51:20" pos:end="51:56"><expr pos:start="51:20" pos:end="51:56"><literal type="string" pos:start="51:20" pos:end="51:56">"CrystalHD: parser picture type %d\n"</literal></expr></argument>,

                   <argument pos:start="53:20" pos:end="53:41"><expr pos:start="53:20" pos:end="53:41"><name pos:start="53:20" pos:end="53:41"><name pos:start="53:20" pos:end="53:20">h</name><operator pos:start="53:21" pos:end="53:22">-&gt;</operator><name pos:start="53:23" pos:end="53:23">s</name><operator pos:start="53:24" pos:end="53:24">.</operator><name pos:start="53:25" pos:end="53:41">picture_structure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="55:13" pos:end="55:46"><expr pos:start="55:13" pos:end="55:45"><name pos:start="55:13" pos:end="55:20">pic_type</name> <operator pos:start="55:22" pos:end="55:22">=</operator> <name pos:start="55:24" pos:end="55:45"><name pos:start="55:24" pos:end="55:24">h</name><operator pos:start="55:25" pos:end="55:26">-&gt;</operator><name pos:start="55:27" pos:end="55:27">s</name><operator pos:start="55:28" pos:end="55:28">.</operator><name pos:start="55:29" pos:end="55:45">picture_structure</name></name></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>



        <if_stmt pos:start="61:9" pos:end="123:9"><if pos:start="61:9" pos:end="117:9">if <condition pos:start="61:12" pos:end="61:33">(<expr pos:start="61:13" pos:end="61:32"><name pos:start="61:13" pos:end="61:15">len</name> <operator pos:start="61:17" pos:end="61:17">&lt;</operator> <name pos:start="61:19" pos:end="61:25">tx_free</name> <operator pos:start="61:27" pos:end="61:27">-</operator> <literal type="number" pos:start="61:29" pos:end="61:32">1024</literal></expr>)</condition> <block pos:start="61:35" pos:end="117:9">{<block_content pos:start="81:13" pos:end="115:34">

            <comment type="block" pos:start="63:13" pos:end="79:15">/*

             * Despite being notionally opaque, either libcrystalhd or

             * the hardware itself will mangle pts values that are too

             * small or too large. The docs claim it should be in units

             * of 100ns. Given that we're nominally dealing with a black

             * box on both sides, any transform we do has no guarantee of

             * avoiding mangling so we need to build a mapping to values

             * we know will not be mangled.

             */</comment>

            <decl_stmt pos:start="81:13" pos:end="81:77"><decl pos:start="81:13" pos:end="81:76"><type pos:start="81:13" pos:end="81:20"><name pos:start="81:13" pos:end="81:20">uint64_t</name></type> <name pos:start="81:22" pos:end="81:24">pts</name> <init pos:start="81:26" pos:end="81:76">= <expr pos:start="81:28" pos:end="81:76"><call pos:start="81:28" pos:end="81:76"><name pos:start="81:28" pos:end="81:43">opaque_list_push</name><argument_list pos:start="81:44" pos:end="81:76">(<argument pos:start="81:45" pos:end="81:48"><expr pos:start="81:45" pos:end="81:48"><name pos:start="81:45" pos:end="81:48">priv</name></expr></argument>, <argument pos:start="81:51" pos:end="81:65"><expr pos:start="81:51" pos:end="81:65"><name pos:start="81:51" pos:end="81:65"><name pos:start="81:51" pos:end="81:55">avctx</name><operator pos:start="81:56" pos:end="81:57">-&gt;</operator><name pos:start="81:58" pos:end="81:60">pkt</name><operator pos:start="81:61" pos:end="81:62">-&gt;</operator><name pos:start="81:63" pos:end="81:65">pts</name></name></expr></argument>, <argument pos:start="81:68" pos:end="81:75"><expr pos:start="81:68" pos:end="81:75"><name pos:start="81:68" pos:end="81:75">pic_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt pos:start="83:13" pos:end="87:13"><if pos:start="83:13" pos:end="87:13">if <condition pos:start="83:16" pos:end="83:21">(<expr pos:start="83:17" pos:end="83:20"><operator pos:start="83:17" pos:end="83:17">!</operator><name pos:start="83:18" pos:end="83:20">pts</name></expr>)</condition> <block pos:start="83:23" pos:end="87:13">{<block_content pos:start="85:17" pos:end="85:39">

                <return pos:start="85:17" pos:end="85:39">return <expr pos:start="85:24" pos:end="85:38"><call pos:start="85:24" pos:end="85:38"><name pos:start="85:24" pos:end="85:30">AVERROR</name><argument_list pos:start="85:31" pos:end="85:38">(<argument pos:start="85:32" pos:end="85:37"><expr pos:start="85:32" pos:end="85:37"><name pos:start="85:32" pos:end="85:37">ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>

            </block_content>}</block></if></if_stmt>

            <expr_stmt pos:start="89:13" pos:end="91:54"><expr pos:start="89:13" pos:end="91:53"><call pos:start="89:13" pos:end="91:53"><name pos:start="89:13" pos:end="89:18">av_log</name><argument_list pos:start="89:19" pos:end="91:53">(<argument pos:start="89:20" pos:end="89:30"><expr pos:start="89:20" pos:end="89:30"><name pos:start="89:20" pos:end="89:30"><name pos:start="89:20" pos:end="89:23">priv</name><operator pos:start="89:24" pos:end="89:25">-&gt;</operator><name pos:start="89:26" pos:end="89:30">avctx</name></name></expr></argument>, <argument pos:start="89:33" pos:end="89:46"><expr pos:start="89:33" pos:end="89:46"><name pos:start="89:33" pos:end="89:46">AV_LOG_VERBOSE</name></expr></argument>,

                   <argument pos:start="91:20" pos:end="91:47"><expr pos:start="91:20" pos:end="91:47"><literal type="string" pos:start="91:20" pos:end="91:37">"input \"pts\": %"</literal><name pos:start="91:38" pos:end="91:43">PRIu64</name><literal type="string" pos:start="91:44" pos:end="91:47">"\n"</literal></expr></argument>, <argument pos:start="91:50" pos:end="91:52"><expr pos:start="91:50" pos:end="91:52"><name pos:start="91:50" pos:end="91:52">pts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="93:13" pos:end="93:62"><expr pos:start="93:13" pos:end="93:61"><name pos:start="93:13" pos:end="93:15">ret</name> <operator pos:start="93:17" pos:end="93:17">=</operator> <call pos:start="93:19" pos:end="93:61"><name pos:start="93:19" pos:end="93:30">DtsProcInput</name><argument_list pos:start="93:31" pos:end="93:61">(<argument pos:start="93:32" pos:end="93:34"><expr pos:start="93:32" pos:end="93:34"><name pos:start="93:32" pos:end="93:34">dev</name></expr></argument>, <argument pos:start="93:37" pos:end="93:47"><expr pos:start="93:37" pos:end="93:47"><name pos:start="93:37" pos:end="93:47"><name pos:start="93:37" pos:end="93:41">avpkt</name><operator pos:start="93:42" pos:end="93:43">-&gt;</operator><name pos:start="93:44" pos:end="93:47">data</name></name></expr></argument>, <argument pos:start="93:50" pos:end="93:52"><expr pos:start="93:50" pos:end="93:52"><name pos:start="93:50" pos:end="93:52">len</name></expr></argument>, <argument pos:start="93:55" pos:end="93:57"><expr pos:start="93:55" pos:end="93:57"><name pos:start="93:55" pos:end="93:57">pts</name></expr></argument>, <argument pos:start="93:60" pos:end="93:60"><expr pos:start="93:60" pos:end="93:60"><literal type="number" pos:start="93:60" pos:end="93:60">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt pos:start="95:13" pos:end="113:13"><if pos:start="95:13" pos:end="105:13">if <condition pos:start="95:16" pos:end="95:35">(<expr pos:start="95:17" pos:end="95:34"><name pos:start="95:17" pos:end="95:19">ret</name> <operator pos:start="95:21" pos:end="95:22">==</operator> <name pos:start="95:24" pos:end="95:34">BC_STS_BUSY</name></expr>)</condition> <block pos:start="95:37" pos:end="105:13">{<block_content pos:start="97:17" pos:end="103:38">

                <expr_stmt pos:start="97:17" pos:end="99:63"><expr pos:start="97:17" pos:end="99:62"><call pos:start="97:17" pos:end="99:62"><name pos:start="97:17" pos:end="97:22">av_log</name><argument_list pos:start="97:23" pos:end="99:62">(<argument pos:start="97:24" pos:end="97:28"><expr pos:start="97:24" pos:end="97:28"><name pos:start="97:24" pos:end="97:28">avctx</name></expr></argument>, <argument pos:start="97:31" pos:end="97:44"><expr pos:start="97:31" pos:end="97:44"><name pos:start="97:31" pos:end="97:44">AV_LOG_WARNING</name></expr></argument>,

                       <argument pos:start="99:24" pos:end="99:61"><expr pos:start="99:24" pos:end="99:61"><literal type="string" pos:start="99:24" pos:end="99:61">"CrystalHD: ProcInput returned busy\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt pos:start="101:17" pos:end="101:34"><expr pos:start="101:17" pos:end="101:33"><call pos:start="101:17" pos:end="101:33"><name pos:start="101:17" pos:end="101:22">usleep</name><argument_list pos:start="101:23" pos:end="101:33">(<argument pos:start="101:24" pos:end="101:32"><expr pos:start="101:24" pos:end="101:32"><name pos:start="101:24" pos:end="101:32">BASE_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return pos:start="103:17" pos:end="103:38">return <expr pos:start="103:24" pos:end="103:37"><call pos:start="103:24" pos:end="103:37"><name pos:start="103:24" pos:end="103:30">AVERROR</name><argument_list pos:start="103:31" pos:end="103:37">(<argument pos:start="103:32" pos:end="103:36"><expr pos:start="103:32" pos:end="103:36"><name pos:start="103:32" pos:end="103:36">EBUSY</name></expr></argument>)</argument_list></call></expr>;</return>

            </block_content>}</block></if> <if type="elseif" pos:start="105:15" pos:end="113:13">else if <condition pos:start="105:23" pos:end="105:45">(<expr pos:start="105:24" pos:end="105:44"><name pos:start="105:24" pos:end="105:26">ret</name> <operator pos:start="105:28" pos:end="105:29">!=</operator> <name pos:start="105:31" pos:end="105:44">BC_STS_SUCCESS</name></expr>)</condition> <block pos:start="105:47" pos:end="113:13">{<block_content pos:start="107:17" pos:end="111:26">

                <expr_stmt pos:start="107:17" pos:end="109:65"><expr pos:start="107:17" pos:end="109:64"><call pos:start="107:17" pos:end="109:64"><name pos:start="107:17" pos:end="107:22">av_log</name><argument_list pos:start="107:23" pos:end="109:64">(<argument pos:start="107:24" pos:end="107:28"><expr pos:start="107:24" pos:end="107:28"><name pos:start="107:24" pos:end="107:28">avctx</name></expr></argument>, <argument pos:start="107:31" pos:end="107:42"><expr pos:start="107:31" pos:end="107:42"><name pos:start="107:31" pos:end="107:42">AV_LOG_ERROR</name></expr></argument>,

                       <argument pos:start="109:24" pos:end="109:58"><expr pos:start="109:24" pos:end="109:58"><literal type="string" pos:start="109:24" pos:end="109:58">"CrystalHD: ProcInput failed: %u\n"</literal></expr></argument>, <argument pos:start="109:61" pos:end="109:63"><expr pos:start="109:61" pos:end="109:63"><name pos:start="109:61" pos:end="109:63">ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return pos:start="111:17" pos:end="111:26">return <expr pos:start="111:24" pos:end="111:25"><operator pos:start="111:24" pos:end="111:24">-</operator><literal type="number" pos:start="111:25" pos:end="111:25">1</literal></expr>;</return>

            </block_content>}</block></if></if_stmt>

            <expr_stmt pos:start="115:13" pos:end="115:34"><expr pos:start="115:13" pos:end="115:33"><name pos:start="115:13" pos:end="115:31"><name pos:start="115:13" pos:end="115:17">avctx</name><operator pos:start="115:18" pos:end="115:19">-&gt;</operator><name pos:start="115:20" pos:end="115:31">has_b_frames</name></name><operator pos:start="115:32" pos:end="115:33">++</operator></expr>;</expr_stmt>

        </block_content>}</block></if> <else pos:start="117:11" pos:end="123:9">else <block pos:start="117:16" pos:end="123:9">{<block_content pos:start="119:13" pos:end="121:20">

            <expr_stmt pos:start="119:13" pos:end="119:76"><expr pos:start="119:13" pos:end="119:75"><call pos:start="119:13" pos:end="119:75"><name pos:start="119:13" pos:end="119:18">av_log</name><argument_list pos:start="119:19" pos:end="119:75">(<argument pos:start="119:20" pos:end="119:24"><expr pos:start="119:20" pos:end="119:24"><name pos:start="119:20" pos:end="119:24">avctx</name></expr></argument>, <argument pos:start="119:27" pos:end="119:40"><expr pos:start="119:27" pos:end="119:40"><name pos:start="119:27" pos:end="119:40">AV_LOG_WARNING</name></expr></argument>, <argument pos:start="119:43" pos:end="119:74"><expr pos:start="119:43" pos:end="119:74"><literal type="string" pos:start="119:43" pos:end="119:74">"CrystalHD: Input buffer full\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="121:13" pos:end="121:20"><expr pos:start="121:13" pos:end="121:19"><name pos:start="121:13" pos:end="121:15">len</name> <operator pos:start="121:17" pos:end="121:17">=</operator> <literal type="number" pos:start="121:19" pos:end="121:19">0</literal></expr>;</expr_stmt> <comment type="line" pos:start="121:22" pos:end="121:52">// We didn't consume any bytes.</comment>

        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if> <else pos:start="125:7" pos:end="129:5">else <block pos:start="125:12" pos:end="129:5">{<block_content pos:start="127:9" pos:end="127:70">

        <expr_stmt pos:start="127:9" pos:end="127:70"><expr pos:start="127:9" pos:end="127:69"><call pos:start="127:9" pos:end="127:69"><name pos:start="127:9" pos:end="127:14">av_log</name><argument_list pos:start="127:15" pos:end="127:69">(<argument pos:start="127:16" pos:end="127:20"><expr pos:start="127:16" pos:end="127:20"><name pos:start="127:16" pos:end="127:20">avctx</name></expr></argument>, <argument pos:start="127:23" pos:end="127:33"><expr pos:start="127:23" pos:end="127:33"><name pos:start="127:23" pos:end="127:33">AV_LOG_INFO</name></expr></argument>, <argument pos:start="127:36" pos:end="127:68"><expr pos:start="127:36" pos:end="127:68"><literal type="string" pos:start="127:36" pos:end="127:68">"CrystalHD: No more input data\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></else></if_stmt>



    <if_stmt pos:start="133:5" pos:end="143:5"><if pos:start="133:5" pos:end="143:5">if <condition pos:start="133:8" pos:end="133:31">(<expr pos:start="133:9" pos:end="133:30"><name pos:start="133:9" pos:end="133:30"><name pos:start="133:9" pos:end="133:12">priv</name><operator pos:start="133:13" pos:end="133:14">-&gt;</operator><name pos:start="133:15" pos:end="133:30">skip_next_output</name></name></expr>)</condition> <block pos:start="133:33" pos:end="143:5">{<block_content pos:start="135:9" pos:end="141:19">

        <expr_stmt pos:start="135:9" pos:end="135:76"><expr pos:start="135:9" pos:end="135:75"><call pos:start="135:9" pos:end="135:75"><name pos:start="135:9" pos:end="135:14">av_log</name><argument_list pos:start="135:15" pos:end="135:75">(<argument pos:start="135:16" pos:end="135:20"><expr pos:start="135:16" pos:end="135:20"><name pos:start="135:16" pos:end="135:20">avctx</name></expr></argument>, <argument pos:start="135:23" pos:end="135:36"><expr pos:start="135:23" pos:end="135:36"><name pos:start="135:23" pos:end="135:36">AV_LOG_VERBOSE</name></expr></argument>, <argument pos:start="135:39" pos:end="135:74"><expr pos:start="135:39" pos:end="135:74"><literal type="string" pos:start="135:39" pos:end="135:74">"CrystalHD: Skipping next output.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="137:9" pos:end="137:35"><expr pos:start="137:9" pos:end="137:34"><name pos:start="137:9" pos:end="137:30"><name pos:start="137:9" pos:end="137:12">priv</name><operator pos:start="137:13" pos:end="137:14">-&gt;</operator><name pos:start="137:15" pos:end="137:30">skip_next_output</name></name> <operator pos:start="137:32" pos:end="137:32">=</operator> <literal type="number" pos:start="137:34" pos:end="137:34">0</literal></expr>;</expr_stmt>

        <expr_stmt pos:start="139:9" pos:end="139:30"><expr pos:start="139:9" pos:end="139:29"><name pos:start="139:9" pos:end="139:27"><name pos:start="139:9" pos:end="139:13">avctx</name><operator pos:start="139:14" pos:end="139:15">-&gt;</operator><name pos:start="139:16" pos:end="139:27">has_b_frames</name></name><operator pos:start="139:28" pos:end="139:29">--</operator></expr>;</expr_stmt>

        <return pos:start="141:9" pos:end="141:19">return <expr pos:start="141:16" pos:end="141:18"><name pos:start="141:16" pos:end="141:18">len</name></expr>;</return>

    </block_content>}</block></if></if_stmt>



    <expr_stmt pos:start="147:5" pos:end="147:51"><expr pos:start="147:5" pos:end="147:50"><name pos:start="147:5" pos:end="147:7">ret</name> <operator pos:start="147:9" pos:end="147:9">=</operator> <call pos:start="147:11" pos:end="147:50"><name pos:start="147:11" pos:end="147:28">DtsGetDriverStatus</name><argument_list pos:start="147:29" pos:end="147:50">(<argument pos:start="147:30" pos:end="147:32"><expr pos:start="147:30" pos:end="147:32"><name pos:start="147:30" pos:end="147:32">dev</name></expr></argument>, <argument pos:start="147:35" pos:end="147:49"><expr pos:start="147:35" pos:end="147:49"><operator pos:start="147:35" pos:end="147:35">&amp;</operator><name pos:start="147:36" pos:end="147:49">decoder_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt pos:start="149:5" pos:end="155:5"><if pos:start="149:5" pos:end="155:5">if <condition pos:start="149:8" pos:end="149:30">(<expr pos:start="149:9" pos:end="149:29"><name pos:start="149:9" pos:end="149:11">ret</name> <operator pos:start="149:13" pos:end="149:14">!=</operator> <name pos:start="149:16" pos:end="149:29">BC_STS_SUCCESS</name></expr>)</condition> <block pos:start="149:32" pos:end="155:5">{<block_content pos:start="151:9" pos:end="153:18">

        <expr_stmt pos:start="151:9" pos:end="151:75"><expr pos:start="151:9" pos:end="151:74"><call pos:start="151:9" pos:end="151:74"><name pos:start="151:9" pos:end="151:14">av_log</name><argument_list pos:start="151:15" pos:end="151:74">(<argument pos:start="151:16" pos:end="151:20"><expr pos:start="151:16" pos:end="151:20"><name pos:start="151:16" pos:end="151:20">avctx</name></expr></argument>, <argument pos:start="151:23" pos:end="151:34"><expr pos:start="151:23" pos:end="151:34"><name pos:start="151:23" pos:end="151:34">AV_LOG_ERROR</name></expr></argument>, <argument pos:start="151:37" pos:end="151:73"><expr pos:start="151:37" pos:end="151:73"><literal type="string" pos:start="151:37" pos:end="151:73">"CrystalHD: GetDriverStatus failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return pos:start="153:9" pos:end="153:18">return <expr pos:start="153:16" pos:end="153:17"><operator pos:start="153:16" pos:end="153:16">-</operator><literal type="number" pos:start="153:17" pos:end="153:17">1</literal></expr>;</return>

    </block_content>}</block></if></if_stmt>



    <comment type="block" pos:start="159:5" pos:end="173:7">/*

     * No frames ready. Don't try to extract.

     *

     * Empirical testing shows that ReadyListCount can be a damn lie,

     * and ProcOut still fails when count &gt; 0. The same testing showed

     * that two more iterations were needed before ProcOutput would

     * succeed.

     */</comment>

    <if_stmt pos:start="175:5" pos:end="209:5"><if pos:start="175:5" pos:end="187:5">if <condition pos:start="175:8" pos:end="175:31">(<expr pos:start="175:9" pos:end="175:30"><name pos:start="175:9" pos:end="175:26"><name pos:start="175:9" pos:end="175:12">priv</name><operator pos:start="175:13" pos:end="175:14">-&gt;</operator><name pos:start="175:15" pos:end="175:26">output_ready</name></name> <operator pos:start="175:28" pos:end="175:28">&lt;</operator> <literal type="number" pos:start="175:30" pos:end="175:30">2</literal></expr>)</condition> <block pos:start="175:33" pos:end="187:5">{<block_content pos:start="177:9" pos:end="185:19">

        <if_stmt pos:start="177:9" pos:end="179:33"><if pos:start="177:9" pos:end="179:33">if <condition pos:start="177:12" pos:end="177:47">(<expr pos:start="177:13" pos:end="177:46"><name pos:start="177:13" pos:end="177:41"><name pos:start="177:13" pos:end="177:26">decoder_status</name><operator pos:start="177:27" pos:end="177:27">.</operator><name pos:start="177:28" pos:end="177:41">ReadyListCount</name></name> <operator pos:start="177:43" pos:end="177:44">!=</operator> <literal type="number" pos:start="177:46" pos:end="177:46">0</literal></expr>)</condition><block type="pseudo" pos:start="179:13" pos:end="179:33"><block_content pos:start="179:13" pos:end="179:33">

            <expr_stmt pos:start="179:13" pos:end="179:33"><expr pos:start="179:13" pos:end="179:32"><name pos:start="179:13" pos:end="179:30"><name pos:start="179:13" pos:end="179:16">priv</name><operator pos:start="179:17" pos:end="179:18">-&gt;</operator><name pos:start="179:19" pos:end="179:30">output_ready</name></name><operator pos:start="179:31" pos:end="179:32">++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt pos:start="181:9" pos:end="181:26"><expr pos:start="181:9" pos:end="181:25"><call pos:start="181:9" pos:end="181:25"><name pos:start="181:9" pos:end="181:14">usleep</name><argument_list pos:start="181:15" pos:end="181:25">(<argument pos:start="181:16" pos:end="181:24"><expr pos:start="181:16" pos:end="181:24"><name pos:start="181:16" pos:end="181:24">BASE_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="183:9" pos:end="183:69"><expr pos:start="183:9" pos:end="183:68"><call pos:start="183:9" pos:end="183:68"><name pos:start="183:9" pos:end="183:14">av_log</name><argument_list pos:start="183:15" pos:end="183:68">(<argument pos:start="183:16" pos:end="183:20"><expr pos:start="183:16" pos:end="183:20"><name pos:start="183:16" pos:end="183:20">avctx</name></expr></argument>, <argument pos:start="183:23" pos:end="183:33"><expr pos:start="183:23" pos:end="183:33"><name pos:start="183:23" pos:end="183:33">AV_LOG_INFO</name></expr></argument>, <argument pos:start="183:36" pos:end="183:67"><expr pos:start="183:36" pos:end="183:67"><literal type="string" pos:start="183:36" pos:end="183:67">"CrystalHD: Filling pipeline.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return pos:start="185:9" pos:end="185:19">return <expr pos:start="185:16" pos:end="185:18"><name pos:start="185:16" pos:end="185:18">len</name></expr>;</return>

    </block_content>}</block></if> <if type="elseif" pos:start="187:7" pos:end="209:5">else if <condition pos:start="187:15" pos:end="187:50">(<expr pos:start="187:16" pos:end="187:49"><name pos:start="187:16" pos:end="187:44"><name pos:start="187:16" pos:end="187:29">decoder_status</name><operator pos:start="187:30" pos:end="187:30">.</operator><name pos:start="187:31" pos:end="187:44">ReadyListCount</name></name> <operator pos:start="187:46" pos:end="187:47">==</operator> <literal type="number" pos:start="187:49" pos:end="187:49">0</literal></expr>)</condition> <block pos:start="187:52" pos:end="209:5">{<block_content pos:start="201:9" pos:end="207:19">

        <comment type="block" pos:start="189:9" pos:end="199:11">/*

         * After the pipeline is established, if we encounter a lack of frames

         * that probably means we're not giving the hardware enough time to

         * decode them, so start increasing the wait time at the end of a

         * decode call.

         */</comment>

        <expr_stmt pos:start="201:9" pos:end="201:26"><expr pos:start="201:9" pos:end="201:25"><call pos:start="201:9" pos:end="201:25"><name pos:start="201:9" pos:end="201:14">usleep</name><argument_list pos:start="201:15" pos:end="201:25">(<argument pos:start="201:16" pos:end="201:24"><expr pos:start="201:16" pos:end="201:24"><name pos:start="201:16" pos:end="201:24">BASE_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="203:9" pos:end="203:39"><expr pos:start="203:9" pos:end="203:38"><name pos:start="203:9" pos:end="203:25"><name pos:start="203:9" pos:end="203:12">priv</name><operator pos:start="203:13" pos:end="203:14">-&gt;</operator><name pos:start="203:15" pos:end="203:25">decode_wait</name></name> <operator pos:start="203:27" pos:end="203:28">+=</operator> <name pos:start="203:30" pos:end="203:38">WAIT_UNIT</name></expr>;</expr_stmt>

        <expr_stmt pos:start="205:9" pos:end="205:78"><expr pos:start="205:9" pos:end="205:77"><call pos:start="205:9" pos:end="205:77"><name pos:start="205:9" pos:end="205:14">av_log</name><argument_list pos:start="205:15" pos:end="205:77">(<argument pos:start="205:16" pos:end="205:20"><expr pos:start="205:16" pos:end="205:20"><name pos:start="205:16" pos:end="205:20">avctx</name></expr></argument>, <argument pos:start="205:23" pos:end="205:33"><expr pos:start="205:23" pos:end="205:33"><name pos:start="205:23" pos:end="205:33">AV_LOG_INFO</name></expr></argument>, <argument pos:start="205:36" pos:end="205:76"><expr pos:start="205:36" pos:end="205:76"><literal type="string" pos:start="205:36" pos:end="205:76">"CrystalHD: No frames ready. Returning\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return pos:start="207:9" pos:end="207:19">return <expr pos:start="207:16" pos:end="207:18"><name pos:start="207:16" pos:end="207:18">len</name></expr>;</return>

    </block_content>}</block></if></if_stmt>



    <do pos:start="213:5" pos:end="313:40">do <block pos:start="213:8" pos:end="313:5">{<block_content pos:start="215:9" pos:end="295:9">

        <expr_stmt pos:start="215:9" pos:end="215:59"><expr pos:start="215:9" pos:end="215:58"><name pos:start="215:9" pos:end="215:15">rec_ret</name> <operator pos:start="215:17" pos:end="215:17">=</operator> <call pos:start="215:19" pos:end="215:58"><name pos:start="215:19" pos:end="215:31">receive_frame</name><argument_list pos:start="215:32" pos:end="215:58">(<argument pos:start="215:33" pos:end="215:37"><expr pos:start="215:33" pos:end="215:37"><name pos:start="215:33" pos:end="215:37">avctx</name></expr></argument>, <argument pos:start="215:40" pos:end="215:43"><expr pos:start="215:40" pos:end="215:43"><name pos:start="215:40" pos:end="215:43">data</name></expr></argument>, <argument pos:start="215:46" pos:end="215:54"><expr pos:start="215:46" pos:end="215:54"><name pos:start="215:46" pos:end="215:54">data_size</name></expr></argument>, <argument pos:start="215:57" pos:end="215:57"><expr pos:start="215:57" pos:end="215:57"><literal type="number" pos:start="215:57" pos:end="215:57">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt pos:start="217:9" pos:end="295:9"><if pos:start="217:9" pos:end="237:9">if <condition pos:start="217:12" pos:end="217:49">(<expr pos:start="217:13" pos:end="217:48"><name pos:start="217:13" pos:end="217:19">rec_ret</name> <operator pos:start="217:21" pos:end="217:22">==</operator> <name pos:start="217:24" pos:end="217:29">RET_OK</name> <operator pos:start="217:31" pos:end="217:32">&amp;&amp;</operator> <operator pos:start="217:34" pos:end="217:34">*</operator><name pos:start="217:35" pos:end="217:43">data_size</name> <operator pos:start="217:45" pos:end="217:46">==</operator> <literal type="number" pos:start="217:48" pos:end="217:48">0</literal></expr>)</condition> <block pos:start="217:51" pos:end="237:9">{<block_content pos:start="233:13" pos:end="235:34">

            <comment type="block" pos:start="219:13" pos:end="231:15">/*

             * This case is for when the encoded fields are stored

             * separately and we get a separate avpkt for each one. To keep

             * the pipeline stable, we should return nothing and wait for

             * the next time round to grab the second field.

             * H.264 PAFF is an example of this.

             */</comment>

            <expr_stmt pos:start="233:13" pos:end="233:76"><expr pos:start="233:13" pos:end="233:75"><call pos:start="233:13" pos:end="233:75"><name pos:start="233:13" pos:end="233:18">av_log</name><argument_list pos:start="233:19" pos:end="233:75">(<argument pos:start="233:20" pos:end="233:24"><expr pos:start="233:20" pos:end="233:24"><name pos:start="233:20" pos:end="233:24">avctx</name></expr></argument>, <argument pos:start="233:27" pos:end="233:40"><expr pos:start="233:27" pos:end="233:40"><name pos:start="233:27" pos:end="233:40">AV_LOG_VERBOSE</name></expr></argument>, <argument pos:start="233:43" pos:end="233:74"><expr pos:start="233:43" pos:end="233:74"><literal type="string" pos:start="233:43" pos:end="233:74">"Returning after first field.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="235:13" pos:end="235:34"><expr pos:start="235:13" pos:end="235:33"><name pos:start="235:13" pos:end="235:31"><name pos:start="235:13" pos:end="235:17">avctx</name><operator pos:start="235:18" pos:end="235:19">-&gt;</operator><name pos:start="235:20" pos:end="235:31">has_b_frames</name></name><operator pos:start="235:32" pos:end="235:33">--</operator></expr>;</expr_stmt>

        </block_content>}</block></if> <if type="elseif" pos:start="237:11" pos:end="281:9">else if <condition pos:start="237:19" pos:end="237:50">(<expr pos:start="237:20" pos:end="237:49"><name pos:start="237:20" pos:end="237:26">rec_ret</name> <operator pos:start="237:28" pos:end="237:29">==</operator> <name pos:start="237:31" pos:end="237:49">RET_COPY_NEXT_FIELD</name></expr>)</condition> <block pos:start="237:52" pos:end="281:9">{<block_content pos:start="255:13" pos:end="279:76">

            <comment type="block" pos:start="239:13" pos:end="253:15">/*

             * This case is for when the encoded fields are stored in a

             * single avpkt but the hardware returns then separately. Unless

             * we grab the second field before returning, we'll slip another

             * frame in the pipeline and if that happens a lot, we're sunk.

             * So we have to get that second field now.

             * Interlaced mpeg2 and vc1 are examples of this.

             */</comment>

            <expr_stmt pos:start="255:13" pos:end="255:75"><expr pos:start="255:13" pos:end="255:74"><call pos:start="255:13" pos:end="255:74"><name pos:start="255:13" pos:end="255:18">av_log</name><argument_list pos:start="255:19" pos:end="255:74">(<argument pos:start="255:20" pos:end="255:24"><expr pos:start="255:20" pos:end="255:24"><name pos:start="255:20" pos:end="255:24">avctx</name></expr></argument>, <argument pos:start="255:27" pos:end="255:40"><expr pos:start="255:27" pos:end="255:40"><name pos:start="255:27" pos:end="255:40">AV_LOG_VERBOSE</name></expr></argument>, <argument pos:start="255:43" pos:end="255:73"><expr pos:start="255:43" pos:end="255:73"><literal type="string" pos:start="255:43" pos:end="255:73">"Trying to get second field.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while pos:start="257:13" pos:end="277:13">while <condition pos:start="257:19" pos:end="257:21">(<expr pos:start="257:20" pos:end="257:20"><literal type="number" pos:start="257:20" pos:end="257:20">1</literal></expr>)</condition> <block pos:start="257:23" pos:end="277:13">{<block_content pos:start="259:17" pos:end="275:17">

                <expr_stmt pos:start="259:17" pos:end="259:42"><expr pos:start="259:17" pos:end="259:41"><call pos:start="259:17" pos:end="259:41"><name pos:start="259:17" pos:end="259:22">usleep</name><argument_list pos:start="259:23" pos:end="259:41">(<argument pos:start="259:24" pos:end="259:40"><expr pos:start="259:24" pos:end="259:40"><name pos:start="259:24" pos:end="259:40"><name pos:start="259:24" pos:end="259:27">priv</name><operator pos:start="259:28" pos:end="259:29">-&gt;</operator><name pos:start="259:30" pos:end="259:40">decode_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt pos:start="261:17" pos:end="261:63"><expr pos:start="261:17" pos:end="261:62"><name pos:start="261:17" pos:end="261:19">ret</name> <operator pos:start="261:21" pos:end="261:21">=</operator> <call pos:start="261:23" pos:end="261:62"><name pos:start="261:23" pos:end="261:40">DtsGetDriverStatus</name><argument_list pos:start="261:41" pos:end="261:62">(<argument pos:start="261:42" pos:end="261:44"><expr pos:start="261:42" pos:end="261:44"><name pos:start="261:42" pos:end="261:44">dev</name></expr></argument>, <argument pos:start="261:47" pos:end="261:61"><expr pos:start="261:47" pos:end="261:61"><operator pos:start="261:47" pos:end="261:47">&amp;</operator><name pos:start="261:48" pos:end="261:61">decoder_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt pos:start="263:17" pos:end="275:17"><if pos:start="263:17" pos:end="275:17">if <condition pos:start="263:20" pos:end="265:54">(<expr pos:start="263:21" pos:end="265:53"><name pos:start="263:21" pos:end="263:23">ret</name> <operator pos:start="263:25" pos:end="263:26">==</operator> <name pos:start="263:28" pos:end="263:41">BC_STS_SUCCESS</name> <operator pos:start="263:43" pos:end="263:44">&amp;&amp;</operator>

                    <name pos:start="265:21" pos:end="265:49"><name pos:start="265:21" pos:end="265:34">decoder_status</name><operator pos:start="265:35" pos:end="265:35">.</operator><name pos:start="265:36" pos:end="265:49">ReadyListCount</name></name> <operator pos:start="265:51" pos:end="265:51">&gt;</operator> <literal type="number" pos:start="265:53" pos:end="265:53">0</literal></expr>)</condition> <block pos:start="265:56" pos:end="275:17">{<block_content pos:start="267:21" pos:end="273:30">

                    <expr_stmt pos:start="267:21" pos:end="267:71"><expr pos:start="267:21" pos:end="267:70"><name pos:start="267:21" pos:end="267:27">rec_ret</name> <operator pos:start="267:29" pos:end="267:29">=</operator> <call pos:start="267:31" pos:end="267:70"><name pos:start="267:31" pos:end="267:43">receive_frame</name><argument_list pos:start="267:44" pos:end="267:70">(<argument pos:start="267:45" pos:end="267:49"><expr pos:start="267:45" pos:end="267:49"><name pos:start="267:45" pos:end="267:49">avctx</name></expr></argument>, <argument pos:start="267:52" pos:end="267:55"><expr pos:start="267:52" pos:end="267:55"><name pos:start="267:52" pos:end="267:55">data</name></expr></argument>, <argument pos:start="267:58" pos:end="267:66"><expr pos:start="267:58" pos:end="267:66"><name pos:start="267:58" pos:end="267:66">data_size</name></expr></argument>, <argument pos:start="267:69" pos:end="267:69"><expr pos:start="267:69" pos:end="267:69"><literal type="number" pos:start="267:69" pos:end="267:69">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt pos:start="269:21" pos:end="273:30"><if pos:start="269:21" pos:end="273:30">if <condition pos:start="269:24" pos:end="271:45">(<expr pos:start="269:25" pos:end="271:44"><operator pos:start="269:25" pos:end="269:25">(</operator><name pos:start="269:26" pos:end="269:32">rec_ret</name> <operator pos:start="269:34" pos:end="269:35">==</operator> <name pos:start="269:37" pos:end="269:42">RET_OK</name> <operator pos:start="269:44" pos:end="269:45">&amp;&amp;</operator> <operator pos:start="269:47" pos:end="269:47">*</operator><name pos:start="269:48" pos:end="269:56">data_size</name> <operator pos:start="269:58" pos:end="269:58">&gt;</operator> <literal type="number" pos:start="269:60" pos:end="269:60">0</literal><operator pos:start="269:61" pos:end="269:61">)</operator> <operator pos:start="269:63" pos:end="269:64">||</operator>

                        <name pos:start="271:25" pos:end="271:31">rec_ret</name> <operator pos:start="271:33" pos:end="271:34">==</operator> <name pos:start="271:36" pos:end="271:44">RET_ERROR</name></expr>)</condition><block type="pseudo" pos:start="273:25" pos:end="273:30"><block_content pos:start="273:25" pos:end="273:30">

                        <break pos:start="273:25" pos:end="273:30">break;</break></block_content></block></if></if_stmt>

                </block_content>}</block></if></if_stmt>

            </block_content>}</block></while>

            <expr_stmt pos:start="279:13" pos:end="279:76"><expr pos:start="279:13" pos:end="279:75"><call pos:start="279:13" pos:end="279:75"><name pos:start="279:13" pos:end="279:18">av_log</name><argument_list pos:start="279:19" pos:end="279:75">(<argument pos:start="279:20" pos:end="279:24"><expr pos:start="279:20" pos:end="279:24"><name pos:start="279:20" pos:end="279:24">avctx</name></expr></argument>, <argument pos:start="279:27" pos:end="279:40"><expr pos:start="279:27" pos:end="279:40"><name pos:start="279:27" pos:end="279:40">AV_LOG_VERBOSE</name></expr></argument>, <argument pos:start="279:43" pos:end="279:74"><expr pos:start="279:43" pos:end="279:74"><literal type="string" pos:start="279:43" pos:end="279:74">"CrystalHD: Got second field.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if> <if type="elseif" pos:start="281:11" pos:end="295:9">else if <condition pos:start="281:19" pos:end="281:49">(<expr pos:start="281:20" pos:end="281:48"><name pos:start="281:20" pos:end="281:26">rec_ret</name> <operator pos:start="281:28" pos:end="281:29">==</operator> <name pos:start="281:31" pos:end="281:48">RET_SKIP_NEXT_COPY</name></expr>)</condition> <block pos:start="281:51" pos:end="295:9">{<block_content pos:start="289:13" pos:end="293:39">

            <comment type="block" pos:start="283:13" pos:end="287:15">/*

             * Two input packets got turned into a field pair. Gawd.

             */</comment>

            <expr_stmt pos:start="289:13" pos:end="291:58"><expr pos:start="289:13" pos:end="291:57"><call pos:start="289:13" pos:end="291:57"><name pos:start="289:13" pos:end="289:18">av_log</name><argument_list pos:start="289:19" pos:end="291:57">(<argument pos:start="289:20" pos:end="289:24"><expr pos:start="289:20" pos:end="289:24"><name pos:start="289:20" pos:end="289:24">avctx</name></expr></argument>, <argument pos:start="289:27" pos:end="289:40"><expr pos:start="289:27" pos:end="289:40"><name pos:start="289:27" pos:end="289:40">AV_LOG_VERBOSE</name></expr></argument>,

                   <argument pos:start="291:20" pos:end="291:56"><expr pos:start="291:20" pos:end="291:56"><literal type="string" pos:start="291:20" pos:end="291:56">"Don't output on next decode call.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="293:13" pos:end="293:39"><expr pos:start="293:13" pos:end="293:38"><name pos:start="293:13" pos:end="293:34"><name pos:start="293:13" pos:end="293:16">priv</name><operator pos:start="293:17" pos:end="293:18">-&gt;</operator><name pos:start="293:19" pos:end="293:34">skip_next_output</name></name> <operator pos:start="293:36" pos:end="293:36">=</operator> <literal type="number" pos:start="293:38" pos:end="293:38">1</literal></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>

        <comment type="block" pos:start="297:9" pos:end="311:11">/*

         * If rec_ret == RET_COPY_AGAIN, that means that either we just handled

         * a FMT_CHANGE event and need to go around again for the actual frame,

         * we got a busy status and need to try again, or we're dealing with

         * packed b-frames, where the hardware strangely returns the packed

         * p-frame twice. We choose to keep the second copy as it carries the

         * valid pts.

         */</comment>

    </block_content>}</block> while <condition pos:start="313:13" pos:end="313:39">(<expr pos:start="313:14" pos:end="313:38"><name pos:start="313:14" pos:end="313:20">rec_ret</name> <operator pos:start="313:22" pos:end="313:23">==</operator> <name pos:start="313:25" pos:end="313:38">RET_COPY_AGAIN</name></expr>)</condition>;</do>

    <expr_stmt pos:start="315:5" pos:end="315:30"><expr pos:start="315:5" pos:end="315:29"><call pos:start="315:5" pos:end="315:29"><name pos:start="315:5" pos:end="315:10">usleep</name><argument_list pos:start="315:11" pos:end="315:29">(<argument pos:start="315:12" pos:end="315:28"><expr pos:start="315:12" pos:end="315:28"><name pos:start="315:12" pos:end="315:28"><name pos:start="315:12" pos:end="315:15">priv</name><operator pos:start="315:16" pos:end="315:17">-&gt;</operator><name pos:start="315:18" pos:end="315:28">decode_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return pos:start="317:5" pos:end="317:15">return <expr pos:start="317:12" pos:end="317:14"><name pos:start="317:12" pos:end="317:14">len</name></expr>;</return>

</block_content>}</block></function>
</unit>
