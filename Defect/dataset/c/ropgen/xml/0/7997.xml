<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:pos="http://www.srcML.org/srcML/position" revision="1.0.0" language="C" filename="dataset/ropgen/aug/0/7997.c" pos:tabs="8"><function pos:start="1:1" pos:end="259:1"><type pos:start="1:1" pos:end="1:24"><specifier pos:start="1:1" pos:end="1:6">static</specifier> <name pos:start="1:8" pos:end="1:11">void</name> <name pos:start="1:13" pos:end="1:24">coroutine_fn</name></type> <name pos:start="1:26" pos:end="1:41">mirror_iteration</name><parameter_list pos:start="1:42" pos:end="1:60">(<parameter pos:start="1:43" pos:end="1:59"><decl pos:start="1:43" pos:end="1:59"><type pos:start="1:43" pos:end="1:58"><name pos:start="1:43" pos:end="1:56">MirrorBlockJob</name> <modifier pos:start="1:58" pos:end="1:58">*</modifier></type><name pos:start="1:59" pos:end="1:59">s</name></decl></parameter>)</parameter_list>

<block pos:start="3:1" pos:end="259:1">{<block_content pos:start="5:5" pos:end="257:45">

    <decl_stmt pos:start="5:5" pos:end="5:44"><decl pos:start="5:5" pos:end="5:43"><type pos:start="5:5" pos:end="5:22"><name pos:start="5:5" pos:end="5:20">BlockDriverState</name> <modifier pos:start="5:22" pos:end="5:22">*</modifier></type><name pos:start="5:23" pos:end="5:28">source</name> <init pos:start="5:30" pos:end="5:43">= <expr pos:start="5:32" pos:end="5:43"><name pos:start="5:32" pos:end="5:43"><name pos:start="5:32" pos:end="5:32">s</name><operator pos:start="5:33" pos:end="5:34">-&gt;</operator><name pos:start="5:35" pos:end="5:40">common</name><operator pos:start="5:41" pos:end="5:41">.</operator><name pos:start="5:42" pos:end="5:43">bs</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="7:5" pos:end="7:49"><decl pos:start="7:5" pos:end="7:18"><type pos:start="7:5" pos:end="7:7"><name pos:start="7:5" pos:end="7:7">int</name></type> <name pos:start="7:9" pos:end="7:18">nb_sectors</name></decl>, <decl pos:start="7:21" pos:end="7:37"><type ref="prev" pos:start="7:5" pos:end="7:7"/><name pos:start="7:21" pos:end="7:37">sectors_per_chunk</name></decl>, <decl pos:start="7:40" pos:end="7:48"><type ref="prev" pos:start="7:5" pos:end="7:7"/><name pos:start="7:40" pos:end="7:48">nb_chunks</name></decl>;</decl_stmt>

    <decl_stmt pos:start="9:5" pos:end="9:74"><decl pos:start="9:5" pos:end="9:15"><type pos:start="9:5" pos:end="9:11"><name pos:start="9:5" pos:end="9:11">int64_t</name></type> <name pos:start="9:13" pos:end="9:15">end</name></decl>, <decl pos:start="9:18" pos:end="9:27"><type ref="prev" pos:start="9:5" pos:end="9:11"/><name pos:start="9:18" pos:end="9:27">sector_num</name></decl>, <decl pos:start="9:30" pos:end="9:39"><type ref="prev" pos:start="9:5" pos:end="9:11"/><name pos:start="9:30" pos:end="9:39">next_chunk</name></decl>, <decl pos:start="9:42" pos:end="9:52"><type ref="prev" pos:start="9:5" pos:end="9:11"/><name pos:start="9:42" pos:end="9:52">next_sector</name></decl>, <decl pos:start="9:55" pos:end="9:73"><type ref="prev" pos:start="9:5" pos:end="9:11"/><name pos:start="9:55" pos:end="9:73">hbitmap_next_sector</name></decl>;</decl_stmt>

    <decl_stmt pos:start="11:5" pos:end="11:17"><decl pos:start="11:5" pos:end="11:16"><type pos:start="11:5" pos:end="11:14"><name pos:start="11:5" pos:end="11:12">MirrorOp</name> <modifier pos:start="11:14" pos:end="11:14">*</modifier></type><name pos:start="11:15" pos:end="11:16">op</name></decl>;</decl_stmt>



    <expr_stmt pos:start="15:5" pos:end="15:47"><expr pos:start="15:5" pos:end="15:46"><name pos:start="15:5" pos:end="15:17"><name pos:start="15:5" pos:end="15:5">s</name><operator pos:start="15:6" pos:end="15:7">-&gt;</operator><name pos:start="15:8" pos:end="15:17">sector_num</name></name> <operator pos:start="15:19" pos:end="15:19">=</operator> <call pos:start="15:21" pos:end="15:46"><name pos:start="15:21" pos:end="15:37">hbitmap_iter_next</name><argument_list pos:start="15:38" pos:end="15:46">(<argument pos:start="15:39" pos:end="15:45"><expr pos:start="15:39" pos:end="15:45"><operator pos:start="15:39" pos:end="15:39">&amp;</operator><name pos:start="15:40" pos:end="15:45"><name pos:start="15:40" pos:end="15:40">s</name><operator pos:start="15:41" pos:end="15:42">-&gt;</operator><name pos:start="15:43" pos:end="15:45">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt pos:start="17:5" pos:end="29:5"><if pos:start="17:5" pos:end="29:5">if <condition pos:start="17:8" pos:end="17:26">(<expr pos:start="17:9" pos:end="17:25"><name pos:start="17:9" pos:end="17:21"><name pos:start="17:9" pos:end="17:9">s</name><operator pos:start="17:10" pos:end="17:11">-&gt;</operator><name pos:start="17:12" pos:end="17:21">sector_num</name></name> <operator pos:start="17:23" pos:end="17:23">&lt;</operator> <literal type="number" pos:start="17:25" pos:end="17:25">0</literal></expr>)</condition> <block pos:start="17:28" pos:end="29:5">{<block_content pos:start="19:9" pos:end="27:35">

        <expr_stmt pos:start="19:9" pos:end="19:63"><expr pos:start="19:9" pos:end="19:62"><call pos:start="19:9" pos:end="19:62"><name pos:start="19:9" pos:end="19:28">bdrv_dirty_iter_init</name><argument_list pos:start="19:29" pos:end="19:62">(<argument pos:start="19:30" pos:end="19:35"><expr pos:start="19:30" pos:end="19:35"><name pos:start="19:30" pos:end="19:35">source</name></expr></argument>, <argument pos:start="19:38" pos:end="19:52"><expr pos:start="19:38" pos:end="19:52"><name pos:start="19:38" pos:end="19:52"><name pos:start="19:38" pos:end="19:38">s</name><operator pos:start="19:39" pos:end="19:40">-&gt;</operator><name pos:start="19:41" pos:end="19:52">dirty_bitmap</name></name></expr></argument>, <argument pos:start="19:55" pos:end="19:61"><expr pos:start="19:55" pos:end="19:61"><operator pos:start="19:55" pos:end="19:55">&amp;</operator><name pos:start="19:56" pos:end="19:61"><name pos:start="19:56" pos:end="19:56">s</name><operator pos:start="19:57" pos:end="19:58">-&gt;</operator><name pos:start="19:59" pos:end="19:61">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="21:9" pos:end="21:51"><expr pos:start="21:9" pos:end="21:50"><name pos:start="21:9" pos:end="21:21"><name pos:start="21:9" pos:end="21:9">s</name><operator pos:start="21:10" pos:end="21:11">-&gt;</operator><name pos:start="21:12" pos:end="21:21">sector_num</name></name> <operator pos:start="21:23" pos:end="21:23">=</operator> <call pos:start="21:25" pos:end="21:50"><name pos:start="21:25" pos:end="21:41">hbitmap_iter_next</name><argument_list pos:start="21:42" pos:end="21:50">(<argument pos:start="21:43" pos:end="21:49"><expr pos:start="21:43" pos:end="21:49"><operator pos:start="21:43" pos:end="21:43">&amp;</operator><name pos:start="21:44" pos:end="21:49"><name pos:start="21:44" pos:end="21:44">s</name><operator pos:start="21:45" pos:end="21:46">-&gt;</operator><name pos:start="21:47" pos:end="21:49">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="23:9" pos:end="25:81"><expr pos:start="23:9" pos:end="25:80"><call pos:start="23:9" pos:end="25:80"><name pos:start="23:9" pos:end="23:33">trace_mirror_restart_iter</name><argument_list pos:start="23:34" pos:end="25:80">(<argument pos:start="23:35" pos:end="23:35"><expr pos:start="23:35" pos:end="23:35"><name pos:start="23:35" pos:end="23:35">s</name></expr></argument>,

                                  <argument pos:start="25:35" pos:end="25:79"><expr pos:start="25:35" pos:end="25:79"><call pos:start="25:35" pos:end="25:79"><name pos:start="25:35" pos:end="25:54">bdrv_get_dirty_count</name><argument_list pos:start="25:55" pos:end="25:79">(<argument pos:start="25:56" pos:end="25:61"><expr pos:start="25:56" pos:end="25:61"><name pos:start="25:56" pos:end="25:61">source</name></expr></argument>, <argument pos:start="25:64" pos:end="25:78"><expr pos:start="25:64" pos:end="25:78"><name pos:start="25:64" pos:end="25:78"><name pos:start="25:64" pos:end="25:64">s</name><operator pos:start="25:65" pos:end="25:66">-&gt;</operator><name pos:start="25:67" pos:end="25:78">dirty_bitmap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="27:9" pos:end="27:35"><expr pos:start="27:9" pos:end="27:34"><call pos:start="27:9" pos:end="27:34"><name pos:start="27:9" pos:end="27:14">assert</name><argument_list pos:start="27:15" pos:end="27:34">(<argument pos:start="27:16" pos:end="27:33"><expr pos:start="27:16" pos:end="27:33"><name pos:start="27:16" pos:end="27:28"><name pos:start="27:16" pos:end="27:16">s</name><operator pos:start="27:17" pos:end="27:18">-&gt;</operator><name pos:start="27:19" pos:end="27:28">sector_num</name></name> <operator pos:start="27:30" pos:end="27:31">&gt;=</operator> <literal type="number" pos:start="27:33" pos:end="27:33">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>



    <expr_stmt pos:start="33:5" pos:end="33:40"><expr pos:start="33:5" pos:end="33:39"><name pos:start="33:5" pos:end="33:23">hbitmap_next_sector</name> <operator pos:start="33:25" pos:end="33:25">=</operator> <name pos:start="33:27" pos:end="33:39"><name pos:start="33:27" pos:end="33:27">s</name><operator pos:start="33:28" pos:end="33:29">-&gt;</operator><name pos:start="33:30" pos:end="33:39">sector_num</name></name></expr>;</expr_stmt>

    <expr_stmt pos:start="35:5" pos:end="35:31"><expr pos:start="35:5" pos:end="35:30"><name pos:start="35:5" pos:end="35:14">sector_num</name> <operator pos:start="35:16" pos:end="35:16">=</operator> <name pos:start="35:18" pos:end="35:30"><name pos:start="35:18" pos:end="35:18">s</name><operator pos:start="35:19" pos:end="35:20">-&gt;</operator><name pos:start="35:21" pos:end="35:30">sector_num</name></name></expr>;</expr_stmt>

    <expr_stmt pos:start="37:5" pos:end="37:59"><expr pos:start="37:5" pos:end="37:58"><name pos:start="37:5" pos:end="37:21">sectors_per_chunk</name> <operator pos:start="37:23" pos:end="37:23">=</operator> <name pos:start="37:25" pos:end="37:38"><name pos:start="37:25" pos:end="37:25">s</name><operator pos:start="37:26" pos:end="37:27">-&gt;</operator><name pos:start="37:28" pos:end="37:38">granularity</name></name> <operator pos:start="37:40" pos:end="37:41">&gt;&gt;</operator> <name pos:start="37:43" pos:end="37:58">BDRV_SECTOR_BITS</name></expr>;</expr_stmt>

    <expr_stmt pos:start="39:5" pos:end="39:44"><expr pos:start="39:5" pos:end="39:43"><name pos:start="39:5" pos:end="39:7">end</name> <operator pos:start="39:9" pos:end="39:9">=</operator> <name pos:start="39:11" pos:end="39:23"><name pos:start="39:11" pos:end="39:11">s</name><operator pos:start="39:12" pos:end="39:13">-&gt;</operator><name pos:start="39:14" pos:end="39:19">common</name><operator pos:start="39:20" pos:end="39:20">.</operator><name pos:start="39:21" pos:end="39:23">len</name></name> <operator pos:start="39:25" pos:end="39:26">&gt;&gt;</operator> <name pos:start="39:28" pos:end="39:43">BDRV_SECTOR_BITS</name></expr>;</expr_stmt>



    <comment type="block" pos:start="43:5" pos:end="67:7">/* Extend the QEMUIOVector to include all adjacent blocks that will

     * be copied in this operation.

     *

     * We have to do this if we have no backing file yet in the destination,

     * and the cluster size is very large.  Then we need to do COW ourselves.

     * The first time a cluster is copied, copy it entirely.  Note that,

     * because both the granularity and the cluster size are powers of two,

     * the number of sectors to copy cannot exceed one cluster.

     *

     * We also want to extend the QEMUIOVector to include more adjacent

     * dirty blocks if possible, to limit the number of I/O operations and

     * run efficiently even with a small granularity.

     */</comment>

    <expr_stmt pos:start="69:5" pos:end="69:18"><expr pos:start="69:5" pos:end="69:17"><name pos:start="69:5" pos:end="69:13">nb_chunks</name> <operator pos:start="69:15" pos:end="69:15">=</operator> <literal type="number" pos:start="69:17" pos:end="69:17">0</literal></expr>;</expr_stmt>

    <expr_stmt pos:start="71:5" pos:end="71:19"><expr pos:start="71:5" pos:end="71:18"><name pos:start="71:5" pos:end="71:14">nb_sectors</name> <operator pos:start="71:16" pos:end="71:16">=</operator> <literal type="number" pos:start="71:18" pos:end="71:18">0</literal></expr>;</expr_stmt>

    <expr_stmt pos:start="73:5" pos:end="73:29"><expr pos:start="73:5" pos:end="73:28"><name pos:start="73:5" pos:end="73:15">next_sector</name> <operator pos:start="73:17" pos:end="73:17">=</operator> <name pos:start="73:19" pos:end="73:28">sector_num</name></expr>;</expr_stmt>

    <expr_stmt pos:start="75:5" pos:end="75:48"><expr pos:start="75:5" pos:end="75:47"><name pos:start="75:5" pos:end="75:14">next_chunk</name> <operator pos:start="75:16" pos:end="75:16">=</operator> <name pos:start="75:18" pos:end="75:27">sector_num</name> <operator pos:start="75:29" pos:end="75:29">/</operator> <name pos:start="75:31" pos:end="75:47">sectors_per_chunk</name></expr>;</expr_stmt>



    <comment type="block" pos:start="79:5" pos:end="79:79">/* Wait for I/O to this cluster (from a previous iteration) to be done.  */</comment>

    <while pos:start="81:5" pos:end="87:5">while <condition pos:start="81:11" pos:end="81:53">(<expr pos:start="81:12" pos:end="81:52"><call pos:start="81:12" pos:end="81:52"><name pos:start="81:12" pos:end="81:19">test_bit</name><argument_list pos:start="81:20" pos:end="81:52">(<argument pos:start="81:21" pos:end="81:30"><expr pos:start="81:21" pos:end="81:30"><name pos:start="81:21" pos:end="81:30">next_chunk</name></expr></argument>, <argument pos:start="81:33" pos:end="81:51"><expr pos:start="81:33" pos:end="81:51"><name pos:start="81:33" pos:end="81:51"><name pos:start="81:33" pos:end="81:33">s</name><operator pos:start="81:34" pos:end="81:35">-&gt;</operator><name pos:start="81:36" pos:end="81:51">in_flight_bitmap</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="81:55" pos:end="87:5">{<block_content pos:start="83:9" pos:end="85:31">

        <expr_stmt pos:start="83:9" pos:end="83:66"><expr pos:start="83:9" pos:end="83:65"><call pos:start="83:9" pos:end="83:65"><name pos:start="83:9" pos:end="83:36">trace_mirror_yield_in_flight</name><argument_list pos:start="83:37" pos:end="83:65">(<argument pos:start="83:38" pos:end="83:38"><expr pos:start="83:38" pos:end="83:38"><name pos:start="83:38" pos:end="83:38">s</name></expr></argument>, <argument pos:start="83:41" pos:end="83:50"><expr pos:start="83:41" pos:end="83:50"><name pos:start="83:41" pos:end="83:50">sector_num</name></expr></argument>, <argument pos:start="83:53" pos:end="83:64"><expr pos:start="83:53" pos:end="83:64"><name pos:start="83:53" pos:end="83:64"><name pos:start="83:53" pos:end="83:53">s</name><operator pos:start="83:54" pos:end="83:55">-&gt;</operator><name pos:start="83:56" pos:end="83:64">in_flight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="85:9" pos:end="85:31"><expr pos:start="85:9" pos:end="85:30"><call pos:start="85:9" pos:end="85:30"><name pos:start="85:9" pos:end="85:28">qemu_coroutine_yield</name><argument_list pos:start="85:29" pos:end="85:30">()</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></while>



    <do pos:start="91:5" pos:end="185:32">do <block pos:start="91:8" pos:end="185:5">{<block_content pos:start="93:9" pos:end="183:35">

        <decl_stmt pos:start="93:9" pos:end="93:40"><decl pos:start="93:9" pos:end="93:25"><type pos:start="93:9" pos:end="93:11"><name pos:start="93:9" pos:end="93:11">int</name></type> <name pos:start="93:13" pos:end="93:25">added_sectors</name></decl>, <decl pos:start="93:28" pos:end="93:39"><type ref="prev" pos:start="93:9" pos:end="93:11"/><name pos:start="93:28" pos:end="93:39">added_chunks</name></decl>;</decl_stmt>



        <if_stmt pos:start="97:9" pos:end="105:9"><if pos:start="97:9" pos:end="105:9">if <condition pos:start="97:12" pos:end="99:54">(<expr pos:start="97:13" pos:end="99:53"><operator pos:start="97:13" pos:end="97:13">!</operator><call pos:start="97:14" pos:end="97:65"><name pos:start="97:14" pos:end="97:27">bdrv_get_dirty</name><argument_list pos:start="97:28" pos:end="97:65">(<argument pos:start="97:29" pos:end="97:34"><expr pos:start="97:29" pos:end="97:34"><name pos:start="97:29" pos:end="97:34">source</name></expr></argument>, <argument pos:start="97:37" pos:end="97:51"><expr pos:start="97:37" pos:end="97:51"><name pos:start="97:37" pos:end="97:51"><name pos:start="97:37" pos:end="97:37">s</name><operator pos:start="97:38" pos:end="97:39">-&gt;</operator><name pos:start="97:40" pos:end="97:51">dirty_bitmap</name></name></expr></argument>, <argument pos:start="97:54" pos:end="97:64"><expr pos:start="97:54" pos:end="97:64"><name pos:start="97:54" pos:end="97:64">next_sector</name></expr></argument>)</argument_list></call> <operator pos:start="97:67" pos:end="97:68">||</operator>

            <call pos:start="99:13" pos:end="99:53"><name pos:start="99:13" pos:end="99:20">test_bit</name><argument_list pos:start="99:21" pos:end="99:53">(<argument pos:start="99:22" pos:end="99:31"><expr pos:start="99:22" pos:end="99:31"><name pos:start="99:22" pos:end="99:31">next_chunk</name></expr></argument>, <argument pos:start="99:34" pos:end="99:52"><expr pos:start="99:34" pos:end="99:52"><name pos:start="99:34" pos:end="99:52"><name pos:start="99:34" pos:end="99:34">s</name><operator pos:start="99:35" pos:end="99:36">-&gt;</operator><name pos:start="99:37" pos:end="99:52">in_flight_bitmap</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="99:56" pos:end="105:9">{<block_content pos:start="101:13" pos:end="103:18">

            <expr_stmt pos:start="101:13" pos:end="101:35"><expr pos:start="101:13" pos:end="101:34"><call pos:start="101:13" pos:end="101:34"><name pos:start="101:13" pos:end="101:18">assert</name><argument_list pos:start="101:19" pos:end="101:34">(<argument pos:start="101:20" pos:end="101:33"><expr pos:start="101:20" pos:end="101:33"><name pos:start="101:20" pos:end="101:29">nb_sectors</name> <operator pos:start="101:31" pos:end="101:31">&gt;</operator> <literal type="number" pos:start="101:33" pos:end="101:33">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break pos:start="103:13" pos:end="103:18">break;</break>

        </block_content>}</block></if></if_stmt>



        <expr_stmt pos:start="109:9" pos:end="109:42"><expr pos:start="109:9" pos:end="109:41"><name pos:start="109:9" pos:end="109:21">added_sectors</name> <operator pos:start="109:23" pos:end="109:23">=</operator> <name pos:start="109:25" pos:end="109:41">sectors_per_chunk</name></expr>;</expr_stmt>

        <if_stmt pos:start="111:9" pos:end="137:9"><if pos:start="111:9" pos:end="137:9">if <condition pos:start="111:12" pos:end="111:66">(<expr pos:start="111:13" pos:end="111:65"><name pos:start="111:13" pos:end="111:25"><name pos:start="111:13" pos:end="111:13">s</name><operator pos:start="111:14" pos:end="111:15">-&gt;</operator><name pos:start="111:16" pos:end="111:25">cow_bitmap</name></name> <operator pos:start="111:27" pos:end="111:28">&amp;&amp;</operator> <operator pos:start="111:30" pos:end="111:30">!</operator><call pos:start="111:31" pos:end="111:65"><name pos:start="111:31" pos:end="111:38">test_bit</name><argument_list pos:start="111:39" pos:end="111:65">(<argument pos:start="111:40" pos:end="111:49"><expr pos:start="111:40" pos:end="111:49"><name pos:start="111:40" pos:end="111:49">next_chunk</name></expr></argument>, <argument pos:start="111:52" pos:end="111:64"><expr pos:start="111:52" pos:end="111:64"><name pos:start="111:52" pos:end="111:64"><name pos:start="111:52" pos:end="111:52">s</name><operator pos:start="111:53" pos:end="111:54">-&gt;</operator><name pos:start="111:55" pos:end="111:64">cow_bitmap</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="111:68" pos:end="137:9">{<block_content pos:start="113:13" pos:end="135:13">

            <expr_stmt pos:start="113:13" pos:end="117:65"><expr pos:start="113:13" pos:end="117:64"><call pos:start="113:13" pos:end="117:64"><name pos:start="113:13" pos:end="113:34">bdrv_round_to_clusters</name><argument_list pos:start="113:35" pos:end="117:64">(<argument pos:start="113:36" pos:end="113:44"><expr pos:start="113:36" pos:end="113:44"><name pos:start="113:36" pos:end="113:44"><name pos:start="113:36" pos:end="113:36">s</name><operator pos:start="113:37" pos:end="113:38">-&gt;</operator><name pos:start="113:39" pos:end="113:44">target</name></name></expr></argument>,

                                   <argument pos:start="115:36" pos:end="115:46"><expr pos:start="115:36" pos:end="115:46"><name pos:start="115:36" pos:end="115:46">next_sector</name></expr></argument>, <argument pos:start="115:49" pos:end="115:61"><expr pos:start="115:49" pos:end="115:61"><name pos:start="115:49" pos:end="115:61">added_sectors</name></expr></argument>,

                                   <argument pos:start="117:36" pos:end="117:47"><expr pos:start="117:36" pos:end="117:47"><operator pos:start="117:36" pos:end="117:36">&amp;</operator><name pos:start="117:37" pos:end="117:47">next_sector</name></expr></argument>, <argument pos:start="117:50" pos:end="117:63"><expr pos:start="117:50" pos:end="117:63"><operator pos:start="117:50" pos:end="117:50">&amp;</operator><name pos:start="117:51" pos:end="117:63">added_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



            <comment type="block" pos:start="121:13" pos:end="125:15">/* On the first iteration, the rounding may make us copy

             * sectors before the first dirty one.

             */</comment>

            <if_stmt pos:start="127:13" pos:end="135:13"><if pos:start="127:13" pos:end="135:13">if <condition pos:start="127:16" pos:end="127:41">(<expr pos:start="127:17" pos:end="127:40"><name pos:start="127:17" pos:end="127:27">next_sector</name> <operator pos:start="127:29" pos:end="127:29">&lt;</operator> <name pos:start="127:31" pos:end="127:40">sector_num</name></expr>)</condition> <block pos:start="127:43" pos:end="135:13">{<block_content pos:start="129:17" pos:end="133:61">

                <expr_stmt pos:start="129:17" pos:end="129:40"><expr pos:start="129:17" pos:end="129:39"><call pos:start="129:17" pos:end="129:39"><name pos:start="129:17" pos:end="129:22">assert</name><argument_list pos:start="129:23" pos:end="129:39">(<argument pos:start="129:24" pos:end="129:38"><expr pos:start="129:24" pos:end="129:38"><name pos:start="129:24" pos:end="129:33">nb_sectors</name> <operator pos:start="129:35" pos:end="129:36">==</operator> <literal type="number" pos:start="129:38" pos:end="129:38">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt pos:start="131:17" pos:end="131:41"><expr pos:start="131:17" pos:end="131:40"><name pos:start="131:17" pos:end="131:26">sector_num</name> <operator pos:start="131:28" pos:end="131:28">=</operator> <name pos:start="131:30" pos:end="131:40">next_sector</name></expr>;</expr_stmt>

                <expr_stmt pos:start="133:17" pos:end="133:61"><expr pos:start="133:17" pos:end="133:60"><name pos:start="133:17" pos:end="133:26">next_chunk</name> <operator pos:start="133:28" pos:end="133:28">=</operator> <name pos:start="133:30" pos:end="133:40">next_sector</name> <operator pos:start="133:42" pos:end="133:42">/</operator> <name pos:start="133:44" pos:end="133:60">sectors_per_chunk</name></expr>;</expr_stmt>

            </block_content>}</block></if></if_stmt>

        </block_content>}</block></if></if_stmt>



        <expr_stmt pos:start="141:9" pos:end="141:76"><expr pos:start="141:9" pos:end="141:75"><name pos:start="141:9" pos:end="141:21">added_sectors</name> <operator pos:start="141:23" pos:end="141:23">=</operator> <call pos:start="141:25" pos:end="141:75"><name pos:start="141:25" pos:end="141:27">MIN</name><argument_list pos:start="141:28" pos:end="141:75">(<argument pos:start="141:29" pos:end="141:41"><expr pos:start="141:29" pos:end="141:41"><name pos:start="141:29" pos:end="141:41">added_sectors</name></expr></argument>, <argument pos:start="141:44" pos:end="141:74"><expr pos:start="141:44" pos:end="141:74"><name pos:start="141:44" pos:end="141:46">end</name> <operator pos:start="141:48" pos:end="141:48">-</operator> <operator pos:start="141:50" pos:end="141:50">(</operator><name pos:start="141:51" pos:end="141:60">sector_num</name> <operator pos:start="141:62" pos:end="141:62">+</operator> <name pos:start="141:64" pos:end="141:73">nb_sectors</name><operator pos:start="141:74" pos:end="141:74">)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="143:9" pos:end="143:83"><expr pos:start="143:9" pos:end="143:82"><name pos:start="143:9" pos:end="143:20">added_chunks</name> <operator pos:start="143:22" pos:end="143:22">=</operator> <operator pos:start="143:24" pos:end="143:24">(</operator><name pos:start="143:25" pos:end="143:37">added_sectors</name> <operator pos:start="143:39" pos:end="143:39">+</operator> <name pos:start="143:41" pos:end="143:57">sectors_per_chunk</name> <operator pos:start="143:59" pos:end="143:59">-</operator> <literal type="number" pos:start="143:61" pos:end="143:61">1</literal><operator pos:start="143:62" pos:end="143:62">)</operator> <operator pos:start="143:64" pos:end="143:64">/</operator> <name pos:start="143:66" pos:end="143:82">sectors_per_chunk</name></expr>;</expr_stmt>



        <comment type="block" pos:start="147:9" pos:end="151:11">/* When doing COW, it may happen that there is not enough space for

         * a full cluster.  Wait if that is the case.

         */</comment>

        <while pos:start="153:9" pos:end="159:9">while <condition pos:start="153:15" pos:end="153:66">(<expr pos:start="153:16" pos:end="153:65"><name pos:start="153:16" pos:end="153:24">nb_chunks</name> <operator pos:start="153:26" pos:end="153:27">==</operator> <literal type="number" pos:start="153:29" pos:end="153:29">0</literal> <operator pos:start="153:31" pos:end="153:32">&amp;&amp;</operator> <name pos:start="153:34" pos:end="153:50"><name pos:start="153:34" pos:end="153:34">s</name><operator pos:start="153:35" pos:end="153:36">-&gt;</operator><name pos:start="153:37" pos:end="153:50">buf_free_count</name></name> <operator pos:start="153:52" pos:end="153:52">&lt;</operator> <name pos:start="153:54" pos:end="153:65">added_chunks</name></expr>)</condition> <block pos:start="153:68" pos:end="159:9">{<block_content pos:start="155:13" pos:end="157:35">

            <expr_stmt pos:start="155:13" pos:end="155:68"><expr pos:start="155:13" pos:end="155:67"><call pos:start="155:13" pos:end="155:67"><name pos:start="155:13" pos:end="155:39">trace_mirror_yield_buf_busy</name><argument_list pos:start="155:40" pos:end="155:67">(<argument pos:start="155:41" pos:end="155:41"><expr pos:start="155:41" pos:end="155:41"><name pos:start="155:41" pos:end="155:41">s</name></expr></argument>, <argument pos:start="155:44" pos:end="155:52"><expr pos:start="155:44" pos:end="155:52"><name pos:start="155:44" pos:end="155:52">nb_chunks</name></expr></argument>, <argument pos:start="155:55" pos:end="155:66"><expr pos:start="155:55" pos:end="155:66"><name pos:start="155:55" pos:end="155:66"><name pos:start="155:55" pos:end="155:55">s</name><operator pos:start="155:56" pos:end="155:57">-&gt;</operator><name pos:start="155:58" pos:end="155:66">in_flight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="157:13" pos:end="157:35"><expr pos:start="157:13" pos:end="157:34"><call pos:start="157:13" pos:end="157:34"><name pos:start="157:13" pos:end="157:32">qemu_coroutine_yield</name><argument_list pos:start="157:33" pos:end="157:34">()</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></while>

        <if_stmt pos:start="161:9" pos:end="167:9"><if pos:start="161:9" pos:end="167:9">if <condition pos:start="161:12" pos:end="161:57">(<expr pos:start="161:13" pos:end="161:56"><name pos:start="161:13" pos:end="161:29"><name pos:start="161:13" pos:end="161:13">s</name><operator pos:start="161:14" pos:end="161:15">-&gt;</operator><name pos:start="161:16" pos:end="161:29">buf_free_count</name></name> <operator pos:start="161:31" pos:end="161:31">&lt;</operator> <name pos:start="161:33" pos:end="161:41">nb_chunks</name> <operator pos:start="161:43" pos:end="161:43">+</operator> <name pos:start="161:45" pos:end="161:56">added_chunks</name></expr>)</condition> <block pos:start="161:59" pos:end="167:9">{<block_content pos:start="163:13" pos:end="165:18">

            <expr_stmt pos:start="163:13" pos:end="163:68"><expr pos:start="163:13" pos:end="163:67"><call pos:start="163:13" pos:end="163:67"><name pos:start="163:13" pos:end="163:39">trace_mirror_break_buf_busy</name><argument_list pos:start="163:40" pos:end="163:67">(<argument pos:start="163:41" pos:end="163:41"><expr pos:start="163:41" pos:end="163:41"><name pos:start="163:41" pos:end="163:41">s</name></expr></argument>, <argument pos:start="163:44" pos:end="163:52"><expr pos:start="163:44" pos:end="163:52"><name pos:start="163:44" pos:end="163:52">nb_chunks</name></expr></argument>, <argument pos:start="163:55" pos:end="163:66"><expr pos:start="163:55" pos:end="163:66"><name pos:start="163:55" pos:end="163:66"><name pos:start="163:55" pos:end="163:55">s</name><operator pos:start="163:56" pos:end="163:57">-&gt;</operator><name pos:start="163:58" pos:end="163:66">in_flight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break pos:start="165:13" pos:end="165:18">break;</break>

        </block_content>}</block></if></if_stmt>



        <comment type="block" pos:start="171:9" pos:end="171:63">/* We have enough free space to copy these sectors.  */</comment>

        <expr_stmt pos:start="173:9" pos:end="173:66"><expr pos:start="173:9" pos:end="173:65"><call pos:start="173:9" pos:end="173:65"><name pos:start="173:9" pos:end="173:18">bitmap_set</name><argument_list pos:start="173:19" pos:end="173:65">(<argument pos:start="173:20" pos:end="173:38"><expr pos:start="173:20" pos:end="173:38"><name pos:start="173:20" pos:end="173:38"><name pos:start="173:20" pos:end="173:20">s</name><operator pos:start="173:21" pos:end="173:22">-&gt;</operator><name pos:start="173:23" pos:end="173:38">in_flight_bitmap</name></name></expr></argument>, <argument pos:start="173:41" pos:end="173:50"><expr pos:start="173:41" pos:end="173:50"><name pos:start="173:41" pos:end="173:50">next_chunk</name></expr></argument>, <argument pos:start="173:53" pos:end="173:64"><expr pos:start="173:53" pos:end="173:64"><name pos:start="173:53" pos:end="173:64">added_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



        <expr_stmt pos:start="177:9" pos:end="177:36"><expr pos:start="177:9" pos:end="177:35"><name pos:start="177:9" pos:end="177:18">nb_sectors</name> <operator pos:start="177:20" pos:end="177:21">+=</operator> <name pos:start="177:23" pos:end="177:35">added_sectors</name></expr>;</expr_stmt>

        <expr_stmt pos:start="179:9" pos:end="179:34"><expr pos:start="179:9" pos:end="179:33"><name pos:start="179:9" pos:end="179:17">nb_chunks</name> <operator pos:start="179:19" pos:end="179:20">+=</operator> <name pos:start="179:22" pos:end="179:33">added_chunks</name></expr>;</expr_stmt>

        <expr_stmt pos:start="181:9" pos:end="181:37"><expr pos:start="181:9" pos:end="181:36"><name pos:start="181:9" pos:end="181:19">next_sector</name> <operator pos:start="181:21" pos:end="181:22">+=</operator> <name pos:start="181:24" pos:end="181:36">added_sectors</name></expr>;</expr_stmt>

        <expr_stmt pos:start="183:9" pos:end="183:35"><expr pos:start="183:9" pos:end="183:34"><name pos:start="183:9" pos:end="183:18">next_chunk</name> <operator pos:start="183:20" pos:end="183:21">+=</operator> <name pos:start="183:23" pos:end="183:34">added_chunks</name></expr>;</expr_stmt>

    </block_content>}</block> while <condition pos:start="185:13" pos:end="185:31">(<expr pos:start="185:14" pos:end="185:30"><name pos:start="185:14" pos:end="185:24">next_sector</name> <operator pos:start="185:26" pos:end="185:26">&lt;</operator> <name pos:start="185:28" pos:end="185:30">end</name></expr>)</condition>;</do>



    <comment type="block" pos:start="189:5" pos:end="189:63">/* Allocate a MirrorOp that is used as an AIO callback.  */</comment>

    <expr_stmt pos:start="191:5" pos:end="191:31"><expr pos:start="191:5" pos:end="191:30"><name pos:start="191:5" pos:end="191:6">op</name> <operator pos:start="191:8" pos:end="191:8">=</operator> <call pos:start="191:10" pos:end="191:30"><name pos:start="191:10" pos:end="191:20">g_slice_new</name><argument_list pos:start="191:21" pos:end="191:30">(<argument pos:start="191:22" pos:end="191:29"><expr pos:start="191:22" pos:end="191:29"><name pos:start="191:22" pos:end="191:29">MirrorOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt pos:start="193:5" pos:end="193:14"><expr pos:start="193:5" pos:end="193:13"><name pos:start="193:5" pos:end="193:9"><name pos:start="193:5" pos:end="193:6">op</name><operator pos:start="193:7" pos:end="193:8">-&gt;</operator><name pos:start="193:9" pos:end="193:9">s</name></name> <operator pos:start="193:11" pos:end="193:11">=</operator> <name pos:start="193:13" pos:end="193:13">s</name></expr>;</expr_stmt>

    <expr_stmt pos:start="195:5" pos:end="195:32"><expr pos:start="195:5" pos:end="195:31"><name pos:start="195:5" pos:end="195:18"><name pos:start="195:5" pos:end="195:6">op</name><operator pos:start="195:7" pos:end="195:8">-&gt;</operator><name pos:start="195:9" pos:end="195:18">sector_num</name></name> <operator pos:start="195:20" pos:end="195:20">=</operator> <name pos:start="195:22" pos:end="195:31">sector_num</name></expr>;</expr_stmt>

    <expr_stmt pos:start="197:5" pos:end="197:32"><expr pos:start="197:5" pos:end="197:31"><name pos:start="197:5" pos:end="197:18"><name pos:start="197:5" pos:end="197:6">op</name><operator pos:start="197:7" pos:end="197:8">-&gt;</operator><name pos:start="197:9" pos:end="197:18">nb_sectors</name></name> <operator pos:start="197:20" pos:end="197:20">=</operator> <name pos:start="197:22" pos:end="197:31">nb_sectors</name></expr>;</expr_stmt>



    <comment type="block" pos:start="201:5" pos:end="205:7">/* Now make a QEMUIOVector taking enough granularity-sized chunks

     * from s-&gt;buf_free.

     */</comment>

    <expr_stmt pos:start="207:5" pos:end="207:42"><expr pos:start="207:5" pos:end="207:41"><call pos:start="207:5" pos:end="207:41"><name pos:start="207:5" pos:end="207:19">qemu_iovec_init</name><argument_list pos:start="207:20" pos:end="207:41">(<argument pos:start="207:21" pos:end="207:29"><expr pos:start="207:21" pos:end="207:29"><operator pos:start="207:21" pos:end="207:21">&amp;</operator><name pos:start="207:22" pos:end="207:29"><name pos:start="207:22" pos:end="207:23">op</name><operator pos:start="207:24" pos:end="207:25">-&gt;</operator><name pos:start="207:26" pos:end="207:29">qiov</name></name></expr></argument>, <argument pos:start="207:32" pos:end="207:40"><expr pos:start="207:32" pos:end="207:40"><name pos:start="207:32" pos:end="207:40">nb_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt pos:start="209:5" pos:end="209:29"><expr pos:start="209:5" pos:end="209:28"><name pos:start="209:5" pos:end="209:15">next_sector</name> <operator pos:start="209:17" pos:end="209:17">=</operator> <name pos:start="209:19" pos:end="209:28">sector_num</name></expr>;</expr_stmt>

    <while pos:start="211:5" pos:end="241:5">while <condition pos:start="211:11" pos:end="211:27">(<expr pos:start="211:12" pos:end="211:26"><name pos:start="211:12" pos:end="211:20">nb_chunks</name><operator pos:start="211:21" pos:end="211:22">--</operator> <operator pos:start="211:24" pos:end="211:24">&gt;</operator> <literal type="number" pos:start="211:26" pos:end="211:26">0</literal></expr>)</condition> <block pos:start="211:29" pos:end="241:5">{<block_content pos:start="213:9" pos:end="239:41">

        <decl_stmt pos:start="213:9" pos:end="213:57"><decl pos:start="213:9" pos:end="213:56"><type pos:start="213:9" pos:end="213:22"><name pos:start="213:9" pos:end="213:20">MirrorBuffer</name> <modifier pos:start="213:22" pos:end="213:22">*</modifier></type><name pos:start="213:23" pos:end="213:25">buf</name> <init pos:start="213:27" pos:end="213:56">= <expr pos:start="213:29" pos:end="213:56"><call pos:start="213:29" pos:end="213:56"><name pos:start="213:29" pos:end="213:42">QSIMPLEQ_FIRST</name><argument_list pos:start="213:43" pos:end="213:56">(<argument pos:start="213:44" pos:end="213:55"><expr pos:start="213:44" pos:end="213:55"><operator pos:start="213:44" pos:end="213:44">&amp;</operator><name pos:start="213:45" pos:end="213:55"><name pos:start="213:45" pos:end="213:45">s</name><operator pos:start="213:46" pos:end="213:47">-&gt;</operator><name pos:start="213:48" pos:end="213:55">buf_free</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt pos:start="215:9" pos:end="215:49"><expr pos:start="215:9" pos:end="215:48"><call pos:start="215:9" pos:end="215:48"><name pos:start="215:9" pos:end="215:28">QSIMPLEQ_REMOVE_HEAD</name><argument_list pos:start="215:29" pos:end="215:48">(<argument pos:start="215:30" pos:end="215:41"><expr pos:start="215:30" pos:end="215:41"><operator pos:start="215:30" pos:end="215:30">&amp;</operator><name pos:start="215:31" pos:end="215:41"><name pos:start="215:31" pos:end="215:31">s</name><operator pos:start="215:32" pos:end="215:33">-&gt;</operator><name pos:start="215:34" pos:end="215:41">buf_free</name></name></expr></argument>, <argument pos:start="215:44" pos:end="215:47"><expr pos:start="215:44" pos:end="215:47"><name pos:start="215:44" pos:end="215:47">next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="217:9" pos:end="217:28"><expr pos:start="217:9" pos:end="217:27"><name pos:start="217:9" pos:end="217:25"><name pos:start="217:9" pos:end="217:9">s</name><operator pos:start="217:10" pos:end="217:11">-&gt;</operator><name pos:start="217:12" pos:end="217:25">buf_free_count</name></name><operator pos:start="217:26" pos:end="217:27">--</operator></expr>;</expr_stmt>

        <expr_stmt pos:start="219:9" pos:end="219:55"><expr pos:start="219:9" pos:end="219:54"><call pos:start="219:9" pos:end="219:54"><name pos:start="219:9" pos:end="219:22">qemu_iovec_add</name><argument_list pos:start="219:23" pos:end="219:54">(<argument pos:start="219:24" pos:end="219:32"><expr pos:start="219:24" pos:end="219:32"><operator pos:start="219:24" pos:end="219:24">&amp;</operator><name pos:start="219:25" pos:end="219:32"><name pos:start="219:25" pos:end="219:26">op</name><operator pos:start="219:27" pos:end="219:28">-&gt;</operator><name pos:start="219:29" pos:end="219:32">qiov</name></name></expr></argument>, <argument pos:start="219:35" pos:end="219:37"><expr pos:start="219:35" pos:end="219:37"><name pos:start="219:35" pos:end="219:37">buf</name></expr></argument>, <argument pos:start="219:40" pos:end="219:53"><expr pos:start="219:40" pos:end="219:53"><name pos:start="219:40" pos:end="219:53"><name pos:start="219:40" pos:end="219:40">s</name><operator pos:start="219:41" pos:end="219:42">-&gt;</operator><name pos:start="219:43" pos:end="219:53">granularity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



        <comment type="block" pos:start="223:9" pos:end="227:11">/* Advance the HBitmapIter in parallel, so that we do not examine

         * the same sector twice.

         */</comment>

        <if_stmt pos:start="229:9" pos:end="235:9"><if pos:start="229:9" pos:end="235:9">if <condition pos:start="229:12" pos:end="231:68">(<expr pos:start="229:13" pos:end="231:67"><name pos:start="229:13" pos:end="229:23">next_sector</name> <operator pos:start="229:25" pos:end="229:25">&gt;</operator> <name pos:start="229:27" pos:end="229:45">hbitmap_next_sector</name>

            <operator pos:start="231:13" pos:end="231:14">&amp;&amp;</operator> <call pos:start="231:16" pos:end="231:67"><name pos:start="231:16" pos:end="231:29">bdrv_get_dirty</name><argument_list pos:start="231:30" pos:end="231:67">(<argument pos:start="231:31" pos:end="231:36"><expr pos:start="231:31" pos:end="231:36"><name pos:start="231:31" pos:end="231:36">source</name></expr></argument>, <argument pos:start="231:39" pos:end="231:53"><expr pos:start="231:39" pos:end="231:53"><name pos:start="231:39" pos:end="231:53"><name pos:start="231:39" pos:end="231:39">s</name><operator pos:start="231:40" pos:end="231:41">-&gt;</operator><name pos:start="231:42" pos:end="231:53">dirty_bitmap</name></name></expr></argument>, <argument pos:start="231:56" pos:end="231:66"><expr pos:start="231:56" pos:end="231:66"><name pos:start="231:56" pos:end="231:66">next_sector</name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="231:70" pos:end="235:9">{<block_content pos:start="233:13" pos:end="233:61">

            <expr_stmt pos:start="233:13" pos:end="233:61"><expr pos:start="233:13" pos:end="233:60"><name pos:start="233:13" pos:end="233:31">hbitmap_next_sector</name> <operator pos:start="233:33" pos:end="233:33">=</operator> <call pos:start="233:35" pos:end="233:60"><name pos:start="233:35" pos:end="233:51">hbitmap_iter_next</name><argument_list pos:start="233:52" pos:end="233:60">(<argument pos:start="233:53" pos:end="233:59"><expr pos:start="233:53" pos:end="233:59"><operator pos:start="233:53" pos:end="233:53">&amp;</operator><name pos:start="233:54" pos:end="233:59"><name pos:start="233:54" pos:end="233:54">s</name><operator pos:start="233:55" pos:end="233:56">-&gt;</operator><name pos:start="233:57" pos:end="233:59">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>



        <expr_stmt pos:start="239:9" pos:end="239:41"><expr pos:start="239:9" pos:end="239:40"><name pos:start="239:9" pos:end="239:19">next_sector</name> <operator pos:start="239:21" pos:end="239:22">+=</operator> <name pos:start="239:24" pos:end="239:40">sectors_per_chunk</name></expr>;</expr_stmt>

    </block_content>}</block></while>



    <expr_stmt pos:start="245:5" pos:end="245:53"><expr pos:start="245:5" pos:end="245:52"><call pos:start="245:5" pos:end="245:52"><name pos:start="245:5" pos:end="245:20">bdrv_reset_dirty</name><argument_list pos:start="245:21" pos:end="245:52">(<argument pos:start="245:22" pos:end="245:27"><expr pos:start="245:22" pos:end="245:27"><name pos:start="245:22" pos:end="245:27">source</name></expr></argument>, <argument pos:start="245:30" pos:end="245:39"><expr pos:start="245:30" pos:end="245:39"><name pos:start="245:30" pos:end="245:39">sector_num</name></expr></argument>, <argument pos:start="245:42" pos:end="245:51"><expr pos:start="245:42" pos:end="245:51"><name pos:start="245:42" pos:end="245:51">nb_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



    <comment type="block" pos:start="249:5" pos:end="249:34">/* Copy the dirty cluster.  */</comment>

    <expr_stmt pos:start="251:5" pos:end="251:19"><expr pos:start="251:5" pos:end="251:18"><name pos:start="251:5" pos:end="251:16"><name pos:start="251:5" pos:end="251:5">s</name><operator pos:start="251:6" pos:end="251:7">-&gt;</operator><name pos:start="251:8" pos:end="251:16">in_flight</name></name><operator pos:start="251:17" pos:end="251:18">++</operator></expr>;</expr_stmt>

    <expr_stmt pos:start="253:5" pos:end="253:58"><expr pos:start="253:5" pos:end="253:57"><call pos:start="253:5" pos:end="253:57"><name pos:start="253:5" pos:end="253:30">trace_mirror_one_iteration</name><argument_list pos:start="253:31" pos:end="253:57">(<argument pos:start="253:32" pos:end="253:32"><expr pos:start="253:32" pos:end="253:32"><name pos:start="253:32" pos:end="253:32">s</name></expr></argument>, <argument pos:start="253:35" pos:end="253:44"><expr pos:start="253:35" pos:end="253:44"><name pos:start="253:35" pos:end="253:44">sector_num</name></expr></argument>, <argument pos:start="253:47" pos:end="253:56"><expr pos:start="253:47" pos:end="253:56"><name pos:start="253:47" pos:end="253:56">nb_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt pos:start="255:5" pos:end="257:45"><expr pos:start="255:5" pos:end="257:44"><call pos:start="255:5" pos:end="257:44"><name pos:start="255:5" pos:end="255:18">bdrv_aio_readv</name><argument_list pos:start="255:19" pos:end="257:44">(<argument pos:start="255:20" pos:end="255:25"><expr pos:start="255:20" pos:end="255:25"><name pos:start="255:20" pos:end="255:25">source</name></expr></argument>, <argument pos:start="255:28" pos:end="255:37"><expr pos:start="255:28" pos:end="255:37"><name pos:start="255:28" pos:end="255:37">sector_num</name></expr></argument>, <argument pos:start="255:40" pos:end="255:48"><expr pos:start="255:40" pos:end="255:48"><operator pos:start="255:40" pos:end="255:40">&amp;</operator><name pos:start="255:41" pos:end="255:48"><name pos:start="255:41" pos:end="255:42">op</name><operator pos:start="255:43" pos:end="255:44">-&gt;</operator><name pos:start="255:45" pos:end="255:48">qiov</name></name></expr></argument>, <argument pos:start="255:51" pos:end="255:60"><expr pos:start="255:51" pos:end="255:60"><name pos:start="255:51" pos:end="255:60">nb_sectors</name></expr></argument>,

                   <argument pos:start="257:20" pos:end="257:39"><expr pos:start="257:20" pos:end="257:39"><name pos:start="257:20" pos:end="257:39">mirror_read_complete</name></expr></argument>, <argument pos:start="257:42" pos:end="257:43"><expr pos:start="257:42" pos:end="257:43"><name pos:start="257:42" pos:end="257:43">op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>
</unit>
