<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:pos="http://www.srcML.org/srcML/position" revision="1.0.0" language="C" filename="dataset/ropgen/aug/0/10305.c" pos:tabs="8"><function pos:start="1:1" pos:end="251:1"><type pos:start="1:1" pos:end="1:28"><specifier pos:start="1:1" pos:end="1:6">static</specifier> <name pos:start="1:8" pos:end="1:15">uint64_t</name> <name pos:start="1:17" pos:end="1:28">coroutine_fn</name></type> <name pos:start="1:30" pos:end="1:45">mirror_iteration</name><parameter_list pos:start="1:46" pos:end="1:64">(<parameter pos:start="1:47" pos:end="1:63"><decl pos:start="1:47" pos:end="1:63"><type pos:start="1:47" pos:end="1:62"><name pos:start="1:47" pos:end="1:60">MirrorBlockJob</name> <modifier pos:start="1:62" pos:end="1:62">*</modifier></type><name pos:start="1:63" pos:end="1:63">s</name></decl></parameter>)</parameter_list>

<block pos:start="3:1" pos:end="251:1">{<block_content pos:start="5:5" pos:end="249:20">

    <decl_stmt pos:start="5:5" pos:end="5:53"><decl pos:start="5:5" pos:end="5:52"><type pos:start="5:5" pos:end="5:22"><name pos:start="5:5" pos:end="5:20">BlockDriverState</name> <modifier pos:start="5:22" pos:end="5:22">*</modifier></type><name pos:start="5:23" pos:end="5:28">source</name> <init pos:start="5:30" pos:end="5:52">= <expr pos:start="5:32" pos:end="5:52"><call pos:start="5:32" pos:end="5:52"><name pos:start="5:32" pos:end="5:37">blk_bs</name><argument_list pos:start="5:38" pos:end="5:52">(<argument pos:start="5:39" pos:end="5:51"><expr pos:start="5:39" pos:end="5:51"><name pos:start="5:39" pos:end="5:51"><name pos:start="5:39" pos:end="5:39">s</name><operator pos:start="5:40" pos:end="5:41">-&gt;</operator><name pos:start="5:42" pos:end="5:47">common</name><operator pos:start="5:48" pos:end="5:48">.</operator><name pos:start="5:49" pos:end="5:51">blk</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="7:5" pos:end="7:36"><decl pos:start="7:5" pos:end="7:22"><type pos:start="7:5" pos:end="7:11"><name pos:start="7:5" pos:end="7:11">int64_t</name></type> <name pos:start="7:13" pos:end="7:22">sector_num</name></decl>, <decl pos:start="7:25" pos:end="7:35"><type ref="prev" pos:start="7:5" pos:end="7:11"/><name pos:start="7:25" pos:end="7:35">first_chunk</name></decl>;</decl_stmt>

    <decl_stmt pos:start="9:5" pos:end="9:26"><decl pos:start="9:5" pos:end="9:25"><type pos:start="9:5" pos:end="9:12"><name pos:start="9:5" pos:end="9:12">uint64_t</name></type> <name pos:start="9:14" pos:end="9:21">delay_ns</name> <init pos:start="9:23" pos:end="9:25">= <expr pos:start="9:25" pos:end="9:25"><literal type="number" pos:start="9:25" pos:end="9:25">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" pos:start="11:5" pos:end="11:70">/* At least the first dirty chunk is mirrored in one iteration. */</comment>

    <decl_stmt pos:start="13:5" pos:end="13:22"><decl pos:start="13:5" pos:end="13:21"><type pos:start="13:5" pos:end="13:7"><name pos:start="13:5" pos:end="13:7">int</name></type> <name pos:start="13:9" pos:end="13:17">nb_chunks</name> <init pos:start="13:19" pos:end="13:21">= <expr pos:start="13:21" pos:end="13:21"><literal type="number" pos:start="13:21" pos:end="13:21">1</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="15:5" pos:end="15:52"><decl pos:start="15:5" pos:end="15:51"><type pos:start="15:5" pos:end="15:11"><name pos:start="15:5" pos:end="15:11">int64_t</name></type> <name pos:start="15:13" pos:end="15:15">end</name> <init pos:start="15:17" pos:end="15:51">= <expr pos:start="15:19" pos:end="15:51"><name pos:start="15:19" pos:end="15:32"><name pos:start="15:19" pos:end="15:19">s</name><operator pos:start="15:20" pos:end="15:21">-&gt;</operator><name pos:start="15:22" pos:end="15:32">bdev_length</name></name> <operator pos:start="15:34" pos:end="15:34">/</operator> <name pos:start="15:36" pos:end="15:51">BDRV_SECTOR_SIZE</name></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="17:5" pos:end="17:63"><decl pos:start="17:5" pos:end="17:62"><type pos:start="17:5" pos:end="17:7"><name pos:start="17:5" pos:end="17:7">int</name></type> <name pos:start="17:9" pos:end="17:25">sectors_per_chunk</name> <init pos:start="17:27" pos:end="17:62">= <expr pos:start="17:29" pos:end="17:62"><name pos:start="17:29" pos:end="17:42"><name pos:start="17:29" pos:end="17:29">s</name><operator pos:start="17:30" pos:end="17:31">-&gt;</operator><name pos:start="17:32" pos:end="17:42">granularity</name></name> <operator pos:start="17:44" pos:end="17:45">&gt;&gt;</operator> <name pos:start="17:47" pos:end="17:62">BDRV_SECTOR_BITS</name></expr></init></decl>;</decl_stmt>

    <decl_stmt pos:start="19:5" pos:end="19:79"><decl pos:start="19:5" pos:end="19:78"><type pos:start="19:5" pos:end="19:8"><name pos:start="19:5" pos:end="19:8">bool</name></type> <name pos:start="19:10" pos:end="19:24">write_zeroes_ok</name> <init pos:start="19:26" pos:end="19:78">= <expr pos:start="19:28" pos:end="19:78"><call pos:start="19:28" pos:end="19:78"><name pos:start="19:28" pos:end="19:59">bdrv_can_write_zeroes_with_unmap</name><argument_list pos:start="19:60" pos:end="19:78">(<argument pos:start="19:61" pos:end="19:77"><expr pos:start="19:61" pos:end="19:77"><call pos:start="19:61" pos:end="19:77"><name pos:start="19:61" pos:end="19:66">blk_bs</name><argument_list pos:start="19:67" pos:end="19:77">(<argument pos:start="19:68" pos:end="19:76"><expr pos:start="19:68" pos:end="19:76"><name pos:start="19:68" pos:end="19:76"><name pos:start="19:68" pos:end="19:68">s</name><operator pos:start="19:69" pos:end="19:70">-&gt;</operator><name pos:start="19:71" pos:end="19:76">target</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



    <expr_stmt pos:start="23:5" pos:end="23:44"><expr pos:start="23:5" pos:end="23:43"><name pos:start="23:5" pos:end="23:14">sector_num</name> <operator pos:start="23:16" pos:end="23:16">=</operator> <call pos:start="23:18" pos:end="23:43"><name pos:start="23:18" pos:end="23:34">hbitmap_iter_next</name><argument_list pos:start="23:35" pos:end="23:43">(<argument pos:start="23:36" pos:end="23:42"><expr pos:start="23:36" pos:end="23:42"><operator pos:start="23:36" pos:end="23:36">&amp;</operator><name pos:start="23:37" pos:end="23:42"><name pos:start="23:37" pos:end="23:37">s</name><operator pos:start="23:38" pos:end="23:39">-&gt;</operator><name pos:start="23:40" pos:end="23:42">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt pos:start="25:5" pos:end="35:5"><if pos:start="25:5" pos:end="35:5">if <condition pos:start="25:8" pos:end="25:23">(<expr pos:start="25:9" pos:end="25:22"><name pos:start="25:9" pos:end="25:18">sector_num</name> <operator pos:start="25:20" pos:end="25:20">&lt;</operator> <literal type="number" pos:start="25:22" pos:end="25:22">0</literal></expr>)</condition> <block pos:start="25:25" pos:end="35:5">{<block_content pos:start="27:9" pos:end="33:32">

        <expr_stmt pos:start="27:9" pos:end="27:55"><expr pos:start="27:9" pos:end="27:54"><call pos:start="27:9" pos:end="27:54"><name pos:start="27:9" pos:end="27:28">bdrv_dirty_iter_init</name><argument_list pos:start="27:29" pos:end="27:54">(<argument pos:start="27:30" pos:end="27:44"><expr pos:start="27:30" pos:end="27:44"><name pos:start="27:30" pos:end="27:44"><name pos:start="27:30" pos:end="27:30">s</name><operator pos:start="27:31" pos:end="27:32">-&gt;</operator><name pos:start="27:33" pos:end="27:44">dirty_bitmap</name></name></expr></argument>, <argument pos:start="27:47" pos:end="27:53"><expr pos:start="27:47" pos:end="27:53"><operator pos:start="27:47" pos:end="27:47">&amp;</operator><name pos:start="27:48" pos:end="27:53"><name pos:start="27:48" pos:end="27:48">s</name><operator pos:start="27:49" pos:end="27:50">-&gt;</operator><name pos:start="27:51" pos:end="27:53">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="29:9" pos:end="29:48"><expr pos:start="29:9" pos:end="29:47"><name pos:start="29:9" pos:end="29:18">sector_num</name> <operator pos:start="29:20" pos:end="29:20">=</operator> <call pos:start="29:22" pos:end="29:47"><name pos:start="29:22" pos:end="29:38">hbitmap_iter_next</name><argument_list pos:start="29:39" pos:end="29:47">(<argument pos:start="29:40" pos:end="29:46"><expr pos:start="29:40" pos:end="29:46"><operator pos:start="29:40" pos:end="29:40">&amp;</operator><name pos:start="29:41" pos:end="29:46"><name pos:start="29:41" pos:end="29:41">s</name><operator pos:start="29:42" pos:end="29:43">-&gt;</operator><name pos:start="29:44" pos:end="29:46">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="31:9" pos:end="31:76"><expr pos:start="31:9" pos:end="31:75"><call pos:start="31:9" pos:end="31:75"><name pos:start="31:9" pos:end="31:33">trace_mirror_restart_iter</name><argument_list pos:start="31:34" pos:end="31:75">(<argument pos:start="31:35" pos:end="31:35"><expr pos:start="31:35" pos:end="31:35"><name pos:start="31:35" pos:end="31:35">s</name></expr></argument>, <argument pos:start="31:38" pos:end="31:74"><expr pos:start="31:38" pos:end="31:74"><call pos:start="31:38" pos:end="31:74"><name pos:start="31:38" pos:end="31:57">bdrv_get_dirty_count</name><argument_list pos:start="31:58" pos:end="31:74">(<argument pos:start="31:59" pos:end="31:73"><expr pos:start="31:59" pos:end="31:73"><name pos:start="31:59" pos:end="31:73"><name pos:start="31:59" pos:end="31:59">s</name><operator pos:start="31:60" pos:end="31:61">-&gt;</operator><name pos:start="31:62" pos:end="31:73">dirty_bitmap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="33:9" pos:end="33:32"><expr pos:start="33:9" pos:end="33:31"><call pos:start="33:9" pos:end="33:31"><name pos:start="33:9" pos:end="33:14">assert</name><argument_list pos:start="33:15" pos:end="33:31">(<argument pos:start="33:16" pos:end="33:30"><expr pos:start="33:16" pos:end="33:30"><name pos:start="33:16" pos:end="33:25">sector_num</name> <operator pos:start="33:27" pos:end="33:28">&gt;=</operator> <literal type="number" pos:start="33:30" pos:end="33:30">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>



    <expr_stmt pos:start="39:5" pos:end="39:49"><expr pos:start="39:5" pos:end="39:48"><name pos:start="39:5" pos:end="39:15">first_chunk</name> <operator pos:start="39:17" pos:end="39:17">=</operator> <name pos:start="39:19" pos:end="39:28">sector_num</name> <operator pos:start="39:30" pos:end="39:30">/</operator> <name pos:start="39:32" pos:end="39:48">sectors_per_chunk</name></expr>;</expr_stmt>

    <while pos:start="41:5" pos:end="47:5">while <condition pos:start="41:11" pos:end="41:54">(<expr pos:start="41:12" pos:end="41:53"><call pos:start="41:12" pos:end="41:53"><name pos:start="41:12" pos:end="41:19">test_bit</name><argument_list pos:start="41:20" pos:end="41:53">(<argument pos:start="41:21" pos:end="41:31"><expr pos:start="41:21" pos:end="41:31"><name pos:start="41:21" pos:end="41:31">first_chunk</name></expr></argument>, <argument pos:start="41:34" pos:end="41:52"><expr pos:start="41:34" pos:end="41:52"><name pos:start="41:34" pos:end="41:52"><name pos:start="41:34" pos:end="41:34">s</name><operator pos:start="41:35" pos:end="41:36">-&gt;</operator><name pos:start="41:37" pos:end="41:52">in_flight_bitmap</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="41:56" pos:end="47:5">{<block_content pos:start="43:9" pos:end="45:30">

        <expr_stmt pos:start="43:9" pos:end="43:66"><expr pos:start="43:9" pos:end="43:65"><call pos:start="43:9" pos:end="43:65"><name pos:start="43:9" pos:end="43:36">trace_mirror_yield_in_flight</name><argument_list pos:start="43:37" pos:end="43:65">(<argument pos:start="43:38" pos:end="43:38"><expr pos:start="43:38" pos:end="43:38"><name pos:start="43:38" pos:end="43:38">s</name></expr></argument>, <argument pos:start="43:41" pos:end="43:50"><expr pos:start="43:41" pos:end="43:50"><name pos:start="43:41" pos:end="43:50">sector_num</name></expr></argument>, <argument pos:start="43:53" pos:end="43:64"><expr pos:start="43:53" pos:end="43:64"><name pos:start="43:53" pos:end="43:64"><name pos:start="43:53" pos:end="43:53">s</name><operator pos:start="43:54" pos:end="43:55">-&gt;</operator><name pos:start="43:56" pos:end="43:64">in_flight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="45:9" pos:end="45:30"><expr pos:start="45:9" pos:end="45:29"><call pos:start="45:9" pos:end="45:29"><name pos:start="45:9" pos:end="45:26">mirror_wait_for_io</name><argument_list pos:start="45:27" pos:end="45:29">(<argument pos:start="45:28" pos:end="45:28"><expr pos:start="45:28" pos:end="45:28"><name pos:start="45:28" pos:end="45:28">s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></while>



    <expr_stmt pos:start="51:5" pos:end="51:38"><expr pos:start="51:5" pos:end="51:37"><call pos:start="51:5" pos:end="51:37"><name pos:start="51:5" pos:end="51:25">block_job_pause_point</name><argument_list pos:start="51:26" pos:end="51:37">(<argument pos:start="51:27" pos:end="51:36"><expr pos:start="51:27" pos:end="51:36"><operator pos:start="51:27" pos:end="51:27">&amp;</operator><name pos:start="51:28" pos:end="51:36"><name pos:start="51:28" pos:end="51:28">s</name><operator pos:start="51:29" pos:end="51:30">-&gt;</operator><name pos:start="51:31" pos:end="51:36">common</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



    <comment type="block" pos:start="55:5" pos:end="57:55">/* Find the number of consective dirty chunks following the first dirty

     * one, and wait for in flight requests in them. */</comment>

    <while pos:start="59:5" pos:end="99:5">while <condition pos:start="59:11" pos:end="59:77">(<expr pos:start="59:12" pos:end="59:76"><name pos:start="59:12" pos:end="59:20">nb_chunks</name> <operator pos:start="59:22" pos:end="59:22">*</operator> <name pos:start="59:24" pos:end="59:40">sectors_per_chunk</name> <operator pos:start="59:42" pos:end="59:42">&lt;</operator> <operator pos:start="59:44" pos:end="59:44">(</operator><name pos:start="59:45" pos:end="59:55"><name pos:start="59:45" pos:end="59:45">s</name><operator pos:start="59:46" pos:end="59:47">-&gt;</operator><name pos:start="59:48" pos:end="59:55">buf_size</name></name> <operator pos:start="59:57" pos:end="59:58">&gt;&gt;</operator> <name pos:start="59:60" pos:end="59:75">BDRV_SECTOR_BITS</name><operator pos:start="59:76" pos:end="59:76">)</operator></expr>)</condition> <block pos:start="59:79" pos:end="99:5">{<block_content pos:start="61:9" pos:end="97:20">

        <decl_stmt pos:start="61:9" pos:end="61:29"><decl pos:start="61:9" pos:end="61:28"><type pos:start="61:9" pos:end="61:15"><name pos:start="61:9" pos:end="61:15">int64_t</name></type> <name pos:start="61:17" pos:end="61:28">hbitmap_next</name></decl>;</decl_stmt>

        <decl_stmt pos:start="63:9" pos:end="63:73"><decl pos:start="63:9" pos:end="63:72"><type pos:start="63:9" pos:end="63:15"><name pos:start="63:9" pos:end="63:15">int64_t</name></type> <name pos:start="63:17" pos:end="63:27">next_sector</name> <init pos:start="63:29" pos:end="63:72">= <expr pos:start="63:31" pos:end="63:72"><name pos:start="63:31" pos:end="63:40">sector_num</name> <operator pos:start="63:42" pos:end="63:42">+</operator> <name pos:start="63:44" pos:end="63:52">nb_chunks</name> <operator pos:start="63:54" pos:end="63:54">*</operator> <name pos:start="63:56" pos:end="63:72">sectors_per_chunk</name></expr></init></decl>;</decl_stmt>

        <decl_stmt pos:start="65:9" pos:end="65:61"><decl pos:start="65:9" pos:end="65:60"><type pos:start="65:9" pos:end="65:15"><name pos:start="65:9" pos:end="65:15">int64_t</name></type> <name pos:start="65:17" pos:end="65:26">next_chunk</name> <init pos:start="65:28" pos:end="65:60">= <expr pos:start="65:30" pos:end="65:60"><name pos:start="65:30" pos:end="65:40">next_sector</name> <operator pos:start="65:42" pos:end="65:42">/</operator> <name pos:start="65:44" pos:end="65:60">sectors_per_chunk</name></expr></init></decl>;</decl_stmt>

        <if_stmt pos:start="67:9" pos:end="73:9"><if pos:start="67:9" pos:end="73:9">if <condition pos:start="67:12" pos:end="69:66">(<expr pos:start="67:13" pos:end="69:65"><name pos:start="67:13" pos:end="67:23">next_sector</name> <operator pos:start="67:25" pos:end="67:26">&gt;=</operator> <name pos:start="67:28" pos:end="67:30">end</name> <operator pos:start="67:32" pos:end="67:33">||</operator>

            <operator pos:start="69:13" pos:end="69:13">!</operator><call pos:start="69:14" pos:end="69:65"><name pos:start="69:14" pos:end="69:27">bdrv_get_dirty</name><argument_list pos:start="69:28" pos:end="69:65">(<argument pos:start="69:29" pos:end="69:34"><expr pos:start="69:29" pos:end="69:34"><name pos:start="69:29" pos:end="69:34">source</name></expr></argument>, <argument pos:start="69:37" pos:end="69:51"><expr pos:start="69:37" pos:end="69:51"><name pos:start="69:37" pos:end="69:51"><name pos:start="69:37" pos:end="69:37">s</name><operator pos:start="69:38" pos:end="69:39">-&gt;</operator><name pos:start="69:40" pos:end="69:51">dirty_bitmap</name></name></expr></argument>, <argument pos:start="69:54" pos:end="69:64"><expr pos:start="69:54" pos:end="69:64"><name pos:start="69:54" pos:end="69:64">next_sector</name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="69:68" pos:end="73:9">{<block_content pos:start="71:13" pos:end="71:18">

            <break pos:start="71:13" pos:end="71:18">break;</break>

        </block_content>}</block></if></if_stmt>

        <if_stmt pos:start="75:9" pos:end="79:9"><if pos:start="75:9" pos:end="79:9">if <condition pos:start="75:12" pos:end="75:54">(<expr pos:start="75:13" pos:end="75:53"><call pos:start="75:13" pos:end="75:53"><name pos:start="75:13" pos:end="75:20">test_bit</name><argument_list pos:start="75:21" pos:end="75:53">(<argument pos:start="75:22" pos:end="75:31"><expr pos:start="75:22" pos:end="75:31"><name pos:start="75:22" pos:end="75:31">next_chunk</name></expr></argument>, <argument pos:start="75:34" pos:end="75:52"><expr pos:start="75:34" pos:end="75:52"><name pos:start="75:34" pos:end="75:52"><name pos:start="75:34" pos:end="75:34">s</name><operator pos:start="75:35" pos:end="75:36">-&gt;</operator><name pos:start="75:37" pos:end="75:52">in_flight_bitmap</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block pos:start="75:56" pos:end="79:9">{<block_content pos:start="77:13" pos:end="77:18">

            <break pos:start="77:13" pos:end="77:18">break;</break>

        </block_content>}</block></if></if_stmt>



        <expr_stmt pos:start="83:9" pos:end="83:50"><expr pos:start="83:9" pos:end="83:49"><name pos:start="83:9" pos:end="83:20">hbitmap_next</name> <operator pos:start="83:22" pos:end="83:22">=</operator> <call pos:start="83:24" pos:end="83:49"><name pos:start="83:24" pos:end="83:40">hbitmap_iter_next</name><argument_list pos:start="83:41" pos:end="83:49">(<argument pos:start="83:42" pos:end="83:48"><expr pos:start="83:42" pos:end="83:48"><operator pos:start="83:42" pos:end="83:42">&amp;</operator><name pos:start="83:43" pos:end="83:48"><name pos:start="83:43" pos:end="83:43">s</name><operator pos:start="83:44" pos:end="83:45">-&gt;</operator><name pos:start="83:46" pos:end="83:48">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt pos:start="85:9" pos:end="93:9"><if pos:start="85:9" pos:end="93:9">if <condition pos:start="85:12" pos:end="85:59">(<expr pos:start="85:13" pos:end="85:58"><name pos:start="85:13" pos:end="85:24">hbitmap_next</name> <operator pos:start="85:26" pos:end="85:26">&gt;</operator> <name pos:start="85:28" pos:end="85:38">next_sector</name> <operator pos:start="85:40" pos:end="85:41">||</operator> <name pos:start="85:43" pos:end="85:54">hbitmap_next</name> <operator pos:start="85:56" pos:end="85:56">&lt;</operator> <literal type="number" pos:start="85:58" pos:end="85:58">0</literal></expr>)</condition> <block pos:start="85:61" pos:end="93:9">{<block_content pos:start="89:13" pos:end="91:54">

            <comment type="block" pos:start="87:13" pos:end="87:66">/* The bitmap iterator's cache is stale, refresh it */</comment>

            <expr_stmt pos:start="89:13" pos:end="89:54"><expr pos:start="89:13" pos:end="89:53"><call pos:start="89:13" pos:end="89:53"><name pos:start="89:13" pos:end="89:31">bdrv_set_dirty_iter</name><argument_list pos:start="89:32" pos:end="89:53">(<argument pos:start="89:33" pos:end="89:39"><expr pos:start="89:33" pos:end="89:39"><operator pos:start="89:33" pos:end="89:33">&amp;</operator><name pos:start="89:34" pos:end="89:39"><name pos:start="89:34" pos:end="89:34">s</name><operator pos:start="89:35" pos:end="89:36">-&gt;</operator><name pos:start="89:37" pos:end="89:39">hbi</name></name></expr></argument>, <argument pos:start="89:42" pos:end="89:52"><expr pos:start="89:42" pos:end="89:52"><name pos:start="89:42" pos:end="89:52">next_sector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="91:13" pos:end="91:54"><expr pos:start="91:13" pos:end="91:53"><name pos:start="91:13" pos:end="91:24">hbitmap_next</name> <operator pos:start="91:26" pos:end="91:26">=</operator> <call pos:start="91:28" pos:end="91:53"><name pos:start="91:28" pos:end="91:44">hbitmap_iter_next</name><argument_list pos:start="91:45" pos:end="91:53">(<argument pos:start="91:46" pos:end="91:52"><expr pos:start="91:46" pos:end="91:52"><operator pos:start="91:46" pos:end="91:46">&amp;</operator><name pos:start="91:47" pos:end="91:52"><name pos:start="91:47" pos:end="91:47">s</name><operator pos:start="91:48" pos:end="91:49">-&gt;</operator><name pos:start="91:50" pos:end="91:52">hbi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>

        <expr_stmt pos:start="95:9" pos:end="95:44"><expr pos:start="95:9" pos:end="95:43"><call pos:start="95:9" pos:end="95:43"><name pos:start="95:9" pos:end="95:14">assert</name><argument_list pos:start="95:15" pos:end="95:43">(<argument pos:start="95:16" pos:end="95:42"><expr pos:start="95:16" pos:end="95:42"><name pos:start="95:16" pos:end="95:27">hbitmap_next</name> <operator pos:start="95:29" pos:end="95:30">==</operator> <name pos:start="95:32" pos:end="95:42">next_sector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="97:9" pos:end="97:20"><expr pos:start="97:9" pos:end="97:19"><name pos:start="97:9" pos:end="97:17">nb_chunks</name><operator pos:start="97:18" pos:end="97:19">++</operator></expr>;</expr_stmt>

    </block_content>}</block></while>



    <comment type="block" pos:start="103:5" pos:end="109:7">/* Clear dirty bits before querying the block status, because

     * calling bdrv_get_block_status_above could yield - if some blocks are

     * marked dirty in this window, we need to know.

     */</comment>

    <expr_stmt pos:start="111:5" pos:end="113:59"><expr pos:start="111:5" pos:end="113:58"><call pos:start="111:5" pos:end="113:58"><name pos:start="111:5" pos:end="111:27">bdrv_reset_dirty_bitmap</name><argument_list pos:start="111:28" pos:end="113:58">(<argument pos:start="111:29" pos:end="111:43"><expr pos:start="111:29" pos:end="111:43"><name pos:start="111:29" pos:end="111:43"><name pos:start="111:29" pos:end="111:29">s</name><operator pos:start="111:30" pos:end="111:31">-&gt;</operator><name pos:start="111:32" pos:end="111:43">dirty_bitmap</name></name></expr></argument>, <argument pos:start="111:46" pos:end="111:55"><expr pos:start="111:46" pos:end="111:55"><name pos:start="111:46" pos:end="111:55">sector_num</name></expr></argument>,

                            <argument pos:start="113:29" pos:end="113:57"><expr pos:start="113:29" pos:end="113:57"><name pos:start="113:29" pos:end="113:37">nb_chunks</name> <operator pos:start="113:39" pos:end="113:39">*</operator> <name pos:start="113:41" pos:end="113:57">sectors_per_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt pos:start="115:5" pos:end="115:79"><expr pos:start="115:5" pos:end="115:78"><call pos:start="115:5" pos:end="115:78"><name pos:start="115:5" pos:end="115:14">bitmap_set</name><argument_list pos:start="115:15" pos:end="115:78">(<argument pos:start="115:16" pos:end="115:34"><expr pos:start="115:16" pos:end="115:34"><name pos:start="115:16" pos:end="115:34"><name pos:start="115:16" pos:end="115:16">s</name><operator pos:start="115:17" pos:end="115:18">-&gt;</operator><name pos:start="115:19" pos:end="115:34">in_flight_bitmap</name></name></expr></argument>, <argument pos:start="115:37" pos:end="115:66"><expr pos:start="115:37" pos:end="115:66"><name pos:start="115:37" pos:end="115:46">sector_num</name> <operator pos:start="115:48" pos:end="115:48">/</operator> <name pos:start="115:50" pos:end="115:66">sectors_per_chunk</name></expr></argument>, <argument pos:start="115:69" pos:end="115:77"><expr pos:start="115:69" pos:end="115:77"><name pos:start="115:69" pos:end="115:77">nb_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while pos:start="117:5" pos:end="247:5">while <condition pos:start="117:11" pos:end="117:45">(<expr pos:start="117:12" pos:end="117:44"><name pos:start="117:12" pos:end="117:20">nb_chunks</name> <operator pos:start="117:22" pos:end="117:22">&gt;</operator> <literal type="number" pos:start="117:24" pos:end="117:24">0</literal> <operator pos:start="117:26" pos:end="117:27">&amp;&amp;</operator> <name pos:start="117:29" pos:end="117:38">sector_num</name> <operator pos:start="117:40" pos:end="117:40">&lt;</operator> <name pos:start="117:42" pos:end="117:44">end</name></expr>)</condition> <block pos:start="117:47" pos:end="247:5">{<block_content pos:start="119:9" pos:end="245:9">

        <decl_stmt pos:start="119:9" pos:end="119:16"><decl pos:start="119:9" pos:end="119:15"><type pos:start="119:9" pos:end="119:11"><name pos:start="119:9" pos:end="119:11">int</name></type> <name pos:start="119:13" pos:end="119:15">ret</name></decl>;</decl_stmt>

        <decl_stmt pos:start="121:9" pos:end="121:40"><decl pos:start="121:9" pos:end="121:22"><type pos:start="121:9" pos:end="121:11"><name pos:start="121:9" pos:end="121:11">int</name></type> <name pos:start="121:13" pos:end="121:22">io_sectors</name></decl>, <decl pos:start="121:25" pos:end="121:39"><type ref="prev" pos:start="121:9" pos:end="121:11"/><name pos:start="121:25" pos:end="121:39">io_sectors_acct</name></decl>;</decl_stmt>

        <decl_stmt pos:start="123:9" pos:end="123:31"><decl pos:start="123:9" pos:end="123:30"><type pos:start="123:9" pos:end="123:26"><name pos:start="123:9" pos:end="123:24">BlockDriverState</name> <modifier pos:start="123:26" pos:end="123:26">*</modifier></type><name pos:start="123:27" pos:end="123:30">file</name></decl>;</decl_stmt>

        <enum pos:start="125:9" pos:end="133:45">enum <name pos:start="125:14" pos:end="125:25">MirrorMethod</name> <block pos:start="125:27" pos:end="133:9">{

            <decl pos:start="127:13" pos:end="127:30"><name pos:start="127:13" pos:end="127:30">MIRROR_METHOD_COPY</name></decl>,

            <decl pos:start="129:13" pos:end="129:30"><name pos:start="129:13" pos:end="129:30">MIRROR_METHOD_ZERO</name></decl>,

            <decl pos:start="131:13" pos:end="131:33"><name pos:start="131:13" pos:end="131:33">MIRROR_METHOD_DISCARD</name></decl>

        }</block> <decl pos:start="133:11" pos:end="133:44"><name pos:start="133:11" pos:end="133:23">mirror_method</name> <init pos:start="133:25" pos:end="133:44">= <expr pos:start="133:27" pos:end="133:44"><name pos:start="133:27" pos:end="133:44">MIRROR_METHOD_COPY</name></expr></init></decl>;</enum>



        <expr_stmt pos:start="137:9" pos:end="137:50"><expr pos:start="137:9" pos:end="137:49"><call pos:start="137:9" pos:end="137:49"><name pos:start="137:9" pos:end="137:14">assert</name><argument_list pos:start="137:15" pos:end="137:49">(<argument pos:start="137:16" pos:end="137:48"><expr pos:start="137:16" pos:end="137:48"><operator pos:start="137:16" pos:end="137:16">!</operator><operator pos:start="137:17" pos:end="137:17">(</operator><name pos:start="137:18" pos:end="137:27">sector_num</name> <operator pos:start="137:29" pos:end="137:29">%</operator> <name pos:start="137:31" pos:end="137:47">sectors_per_chunk</name><operator pos:start="137:48" pos:end="137:48">)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="139:9" pos:end="143:62"><expr pos:start="139:9" pos:end="143:61"><name pos:start="139:9" pos:end="139:11">ret</name> <operator pos:start="139:13" pos:end="139:13">=</operator> <call pos:start="139:15" pos:end="143:61"><name pos:start="139:15" pos:end="139:41">bdrv_get_block_status_above</name><argument_list pos:start="139:42" pos:end="143:61">(<argument pos:start="139:43" pos:end="139:48"><expr pos:start="139:43" pos:end="139:48"><name pos:start="139:43" pos:end="139:48">source</name></expr></argument>, <argument pos:start="139:51" pos:end="139:54"><expr pos:start="139:51" pos:end="139:54"><name pos:start="139:51" pos:end="139:54">NULL</name></expr></argument>, <argument pos:start="139:57" pos:end="139:66"><expr pos:start="139:57" pos:end="139:66"><name pos:start="139:57" pos:end="139:66">sector_num</name></expr></argument>,

                                          <argument pos:start="141:43" pos:end="141:71"><expr pos:start="141:43" pos:end="141:71"><name pos:start="141:43" pos:end="141:51">nb_chunks</name> <operator pos:start="141:53" pos:end="141:53">*</operator> <name pos:start="141:55" pos:end="141:71">sectors_per_chunk</name></expr></argument>,

                                          <argument pos:start="143:43" pos:end="143:53"><expr pos:start="143:43" pos:end="143:53"><operator pos:start="143:43" pos:end="143:43">&amp;</operator><name pos:start="143:44" pos:end="143:53">io_sectors</name></expr></argument>, <argument pos:start="143:56" pos:end="143:60"><expr pos:start="143:56" pos:end="143:60"><operator pos:start="143:56" pos:end="143:56">&amp;</operator><name pos:start="143:57" pos:end="143:60">file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt pos:start="145:9" pos:end="149:9"><if pos:start="145:9" pos:end="149:9">if <condition pos:start="145:12" pos:end="145:20">(<expr pos:start="145:13" pos:end="145:19"><name pos:start="145:13" pos:end="145:15">ret</name> <operator pos:start="145:17" pos:end="145:17">&lt;</operator> <literal type="number" pos:start="145:19" pos:end="145:19">0</literal></expr>)</condition> <block pos:start="145:22" pos:end="149:9">{<block_content pos:start="147:13" pos:end="147:55">

            <expr_stmt pos:start="147:13" pos:end="147:55"><expr pos:start="147:13" pos:end="147:54"><name pos:start="147:13" pos:end="147:22">io_sectors</name> <operator pos:start="147:24" pos:end="147:24">=</operator> <name pos:start="147:26" pos:end="147:34">nb_chunks</name> <operator pos:start="147:36" pos:end="147:36">*</operator> <name pos:start="147:38" pos:end="147:54">sectors_per_chunk</name></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>



        <expr_stmt pos:start="153:9" pos:end="153:53"><expr pos:start="153:9" pos:end="153:52"><name pos:start="153:9" pos:end="153:18">io_sectors</name> <operator pos:start="153:20" pos:end="153:21">-=</operator> <name pos:start="153:23" pos:end="153:32">io_sectors</name> <operator pos:start="153:34" pos:end="153:34">%</operator> <name pos:start="153:36" pos:end="153:52">sectors_per_chunk</name></expr>;</expr_stmt>

        <if_stmt pos:start="155:9" pos:end="183:9"><if pos:start="155:9" pos:end="159:9">if <condition pos:start="155:12" pos:end="155:43">(<expr pos:start="155:13" pos:end="155:42"><name pos:start="155:13" pos:end="155:22">io_sectors</name> <operator pos:start="155:24" pos:end="155:24">&lt;</operator> <name pos:start="155:26" pos:end="155:42">sectors_per_chunk</name></expr>)</condition> <block pos:start="155:45" pos:end="159:9">{<block_content pos:start="157:13" pos:end="157:43">

            <expr_stmt pos:start="157:13" pos:end="157:43"><expr pos:start="157:13" pos:end="157:42"><name pos:start="157:13" pos:end="157:22">io_sectors</name> <operator pos:start="157:24" pos:end="157:24">=</operator> <name pos:start="157:26" pos:end="157:42">sectors_per_chunk</name></expr>;</expr_stmt>

        </block_content>}</block></if> <if type="elseif" pos:start="159:11" pos:end="183:9">else if <condition pos:start="159:19" pos:end="159:56">(<expr pos:start="159:20" pos:end="159:55"><name pos:start="159:20" pos:end="159:22">ret</name> <operator pos:start="159:24" pos:end="159:25">&gt;=</operator> <literal type="number" pos:start="159:27" pos:end="159:27">0</literal> <operator pos:start="159:29" pos:end="159:30">&amp;&amp;</operator> <operator pos:start="159:32" pos:end="159:32">!</operator><operator pos:start="159:33" pos:end="159:33">(</operator><name pos:start="159:34" pos:end="159:36">ret</name> <operator pos:start="159:38" pos:end="159:38">&amp;</operator> <name pos:start="159:40" pos:end="159:54">BDRV_BLOCK_DATA</name><operator pos:start="159:55" pos:end="159:55">)</operator></expr>)</condition> <block pos:start="159:58" pos:end="183:9">{<block_content pos:start="161:13" pos:end="181:13">

            <decl_stmt pos:start="161:13" pos:end="161:38"><decl pos:start="161:13" pos:end="161:37"><type pos:start="161:13" pos:end="161:19"><name pos:start="161:13" pos:end="161:19">int64_t</name></type> <name pos:start="161:21" pos:end="161:37">target_sector_num</name></decl>;</decl_stmt>

            <decl_stmt pos:start="163:13" pos:end="163:34"><decl pos:start="163:13" pos:end="163:33"><type pos:start="163:13" pos:end="163:15"><name pos:start="163:13" pos:end="163:15">int</name></type> <name pos:start="163:17" pos:end="163:33">target_nb_sectors</name></decl>;</decl_stmt>

            <expr_stmt pos:start="165:13" pos:end="169:63"><expr pos:start="165:13" pos:end="169:62"><call pos:start="165:13" pos:end="169:62"><name pos:start="165:13" pos:end="165:42">bdrv_round_sectors_to_clusters</name><argument_list pos:start="165:43" pos:end="169:62">(<argument pos:start="165:44" pos:end="165:60"><expr pos:start="165:44" pos:end="165:60"><call pos:start="165:44" pos:end="165:60"><name pos:start="165:44" pos:end="165:49">blk_bs</name><argument_list pos:start="165:50" pos:end="165:60">(<argument pos:start="165:51" pos:end="165:59"><expr pos:start="165:51" pos:end="165:59"><name pos:start="165:51" pos:end="165:59"><name pos:start="165:51" pos:end="165:51">s</name><operator pos:start="165:52" pos:end="165:53">-&gt;</operator><name pos:start="165:54" pos:end="165:59">target</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument pos:start="165:63" pos:end="165:72"><expr pos:start="165:63" pos:end="165:72"><name pos:start="165:63" pos:end="165:72">sector_num</name></expr></argument>,

                                           <argument pos:start="167:44" pos:end="167:53"><expr pos:start="167:44" pos:end="167:53"><name pos:start="167:44" pos:end="167:53">io_sectors</name></expr></argument>,  <argument pos:start="167:57" pos:end="167:74"><expr pos:start="167:57" pos:end="167:74"><operator pos:start="167:57" pos:end="167:57">&amp;</operator><name pos:start="167:58" pos:end="167:74">target_sector_num</name></expr></argument>,

                                           <argument pos:start="169:44" pos:end="169:61"><expr pos:start="169:44" pos:end="169:61"><operator pos:start="169:44" pos:end="169:44">&amp;</operator><name pos:start="169:45" pos:end="169:61">target_nb_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt pos:start="171:13" pos:end="181:13"><if pos:start="171:13" pos:end="181:13">if <condition pos:start="171:16" pos:end="173:48">(<expr pos:start="171:17" pos:end="173:47"><name pos:start="171:17" pos:end="171:33">target_sector_num</name> <operator pos:start="171:35" pos:end="171:36">==</operator> <name pos:start="171:38" pos:end="171:47">sector_num</name> <operator pos:start="171:49" pos:end="171:50">&amp;&amp;</operator>

                <name pos:start="173:17" pos:end="173:33">target_nb_sectors</name> <operator pos:start="173:35" pos:end="173:36">==</operator> <name pos:start="173:38" pos:end="173:47">io_sectors</name></expr>)</condition> <block pos:start="173:50" pos:end="181:13">{<block_content pos:start="175:17" pos:end="179:58">

                <expr_stmt pos:start="175:17" pos:end="179:58"><expr pos:start="175:17" pos:end="179:57"><name pos:start="175:17" pos:end="175:29">mirror_method</name> <operator pos:start="175:31" pos:end="175:31">=</operator> <ternary pos:start="175:33" pos:end="179:57"><condition pos:start="175:33" pos:end="175:55"><expr pos:start="175:33" pos:end="175:53"><name pos:start="175:33" pos:end="175:35">ret</name> <operator pos:start="175:37" pos:end="175:37">&amp;</operator> <name pos:start="175:39" pos:end="175:53">BDRV_BLOCK_ZERO</name></expr> ?</condition><then pos:start="177:37" pos:end="177:54">

                                    <expr pos:start="177:37" pos:end="177:54"><name pos:start="177:37" pos:end="177:54">MIRROR_METHOD_ZERO</name></expr> </then><else pos:start="177:56" pos:end="179:57">:

                                    <expr pos:start="179:37" pos:end="179:57"><name pos:start="179:37" pos:end="179:57">MIRROR_METHOD_DISCARD</name></expr></else></ternary></expr>;</expr_stmt>

            </block_content>}</block></if></if_stmt>

        </block_content>}</block></if></if_stmt>



        <while pos:start="187:9" pos:end="193:9">while <condition pos:start="187:15" pos:end="187:45">(<expr pos:start="187:16" pos:end="187:44"><name pos:start="187:16" pos:end="187:27"><name pos:start="187:16" pos:end="187:16">s</name><operator pos:start="187:17" pos:end="187:18">-&gt;</operator><name pos:start="187:19" pos:end="187:27">in_flight</name></name> <operator pos:start="187:29" pos:end="187:30">&gt;=</operator> <name pos:start="187:32" pos:end="187:44">MAX_IN_FLIGHT</name></expr>)</condition> <block pos:start="187:47" pos:end="193:9">{<block_content pos:start="189:13" pos:end="191:34">

            <expr_stmt pos:start="189:13" pos:end="189:70"><expr pos:start="189:13" pos:end="189:69"><call pos:start="189:13" pos:end="189:69"><name pos:start="189:13" pos:end="189:40">trace_mirror_yield_in_flight</name><argument_list pos:start="189:41" pos:end="189:69">(<argument pos:start="189:42" pos:end="189:42"><expr pos:start="189:42" pos:end="189:42"><name pos:start="189:42" pos:end="189:42">s</name></expr></argument>, <argument pos:start="189:45" pos:end="189:54"><expr pos:start="189:45" pos:end="189:54"><name pos:start="189:45" pos:end="189:54">sector_num</name></expr></argument>, <argument pos:start="189:57" pos:end="189:68"><expr pos:start="189:57" pos:end="189:68"><name pos:start="189:57" pos:end="189:68"><name pos:start="189:57" pos:end="189:57">s</name><operator pos:start="189:58" pos:end="189:59">-&gt;</operator><name pos:start="189:60" pos:end="189:68">in_flight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="191:13" pos:end="191:34"><expr pos:start="191:13" pos:end="191:33"><call pos:start="191:13" pos:end="191:33"><name pos:start="191:13" pos:end="191:30">mirror_wait_for_io</name><argument_list pos:start="191:31" pos:end="191:33">(<argument pos:start="191:32" pos:end="191:32"><expr pos:start="191:32" pos:end="191:32"><name pos:start="191:32" pos:end="191:32">s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></while>



        <expr_stmt pos:start="197:9" pos:end="197:56"><expr pos:start="197:9" pos:end="197:55"><call pos:start="197:9" pos:end="197:55"><name pos:start="197:9" pos:end="197:27">mirror_clip_sectors</name><argument_list pos:start="197:28" pos:end="197:55">(<argument pos:start="197:29" pos:end="197:29"><expr pos:start="197:29" pos:end="197:29"><name pos:start="197:29" pos:end="197:29">s</name></expr></argument>, <argument pos:start="197:32" pos:end="197:41"><expr pos:start="197:32" pos:end="197:41"><name pos:start="197:32" pos:end="197:41">sector_num</name></expr></argument>, <argument pos:start="197:44" pos:end="197:54"><expr pos:start="197:44" pos:end="197:54"><operator pos:start="197:44" pos:end="197:44">&amp;</operator><name pos:start="197:45" pos:end="197:54">io_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch pos:start="199:9" pos:end="233:9">switch <condition pos:start="199:16" pos:end="199:30">(<expr pos:start="199:17" pos:end="199:29"><name pos:start="199:17" pos:end="199:29">mirror_method</name></expr>)</condition> <block pos:start="199:32" pos:end="233:9">{<block_content pos:start="201:9" pos:end="231:20">

        <case pos:start="201:9" pos:end="201:32">case <expr pos:start="201:14" pos:end="201:31"><name pos:start="201:14" pos:end="201:31">MIRROR_METHOD_COPY</name></expr>:</case>

            <expr_stmt pos:start="203:13" pos:end="203:67"><expr pos:start="203:13" pos:end="203:66"><name pos:start="203:13" pos:end="203:22">io_sectors</name> <operator pos:start="203:24" pos:end="203:24">=</operator> <call pos:start="203:26" pos:end="203:66"><name pos:start="203:26" pos:end="203:39">mirror_do_read</name><argument_list pos:start="203:40" pos:end="203:66">(<argument pos:start="203:41" pos:end="203:41"><expr pos:start="203:41" pos:end="203:41"><name pos:start="203:41" pos:end="203:41">s</name></expr></argument>, <argument pos:start="203:44" pos:end="203:53"><expr pos:start="203:44" pos:end="203:53"><name pos:start="203:44" pos:end="203:53">sector_num</name></expr></argument>, <argument pos:start="203:56" pos:end="203:65"><expr pos:start="203:56" pos:end="203:65"><name pos:start="203:56" pos:end="203:65">io_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt pos:start="205:13" pos:end="205:41"><expr pos:start="205:13" pos:end="205:40"><name pos:start="205:13" pos:end="205:27">io_sectors_acct</name> <operator pos:start="205:29" pos:end="205:29">=</operator> <name pos:start="205:31" pos:end="205:40">io_sectors</name></expr>;</expr_stmt>

            <break pos:start="207:13" pos:end="207:18">break;</break>

        <case pos:start="209:9" pos:end="209:32">case <expr pos:start="209:14" pos:end="209:31"><name pos:start="209:14" pos:end="209:31">MIRROR_METHOD_ZERO</name></expr>:</case>

        <case pos:start="211:9" pos:end="211:35">case <expr pos:start="211:14" pos:end="211:34"><name pos:start="211:14" pos:end="211:34">MIRROR_METHOD_DISCARD</name></expr>:</case>

            <expr_stmt pos:start="213:13" pos:end="215:78"><expr pos:start="213:13" pos:end="215:77"><call pos:start="213:13" pos:end="215:77"><name pos:start="213:13" pos:end="213:37">mirror_do_zero_or_discard</name><argument_list pos:start="213:38" pos:end="215:77">(<argument pos:start="213:39" pos:end="213:39"><expr pos:start="213:39" pos:end="213:39"><name pos:start="213:39" pos:end="213:39">s</name></expr></argument>, <argument pos:start="213:42" pos:end="213:51"><expr pos:start="213:42" pos:end="213:51"><name pos:start="213:42" pos:end="213:51">sector_num</name></expr></argument>, <argument pos:start="213:54" pos:end="213:63"><expr pos:start="213:54" pos:end="213:63"><name pos:start="213:54" pos:end="213:63">io_sectors</name></expr></argument>,

                                      <argument pos:start="215:39" pos:end="215:76"><expr pos:start="215:39" pos:end="215:76"><name pos:start="215:39" pos:end="215:51">mirror_method</name> <operator pos:start="215:53" pos:end="215:54">==</operator> <name pos:start="215:56" pos:end="215:76">MIRROR_METHOD_DISCARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt pos:start="217:13" pos:end="225:13"><if pos:start="217:13" pos:end="221:13">if <condition pos:start="217:16" pos:end="217:32">(<expr pos:start="217:17" pos:end="217:31"><name pos:start="217:17" pos:end="217:31">write_zeroes_ok</name></expr>)</condition> <block pos:start="217:34" pos:end="221:13">{<block_content pos:start="219:17" pos:end="219:36">

                <expr_stmt pos:start="219:17" pos:end="219:36"><expr pos:start="219:17" pos:end="219:35"><name pos:start="219:17" pos:end="219:31">io_sectors_acct</name> <operator pos:start="219:33" pos:end="219:33">=</operator> <literal type="number" pos:start="219:35" pos:end="219:35">0</literal></expr>;</expr_stmt>

            </block_content>}</block></if> <else pos:start="221:15" pos:end="225:13">else <block pos:start="221:20" pos:end="225:13">{<block_content pos:start="223:17" pos:end="223:45">

                <expr_stmt pos:start="223:17" pos:end="223:45"><expr pos:start="223:17" pos:end="223:44"><name pos:start="223:17" pos:end="223:31">io_sectors_acct</name> <operator pos:start="223:33" pos:end="223:33">=</operator> <name pos:start="223:35" pos:end="223:44">io_sectors</name></expr>;</expr_stmt>

            </block_content>}</block></else></if_stmt>

            <break pos:start="227:13" pos:end="227:18">break;</break>

        <default pos:start="229:9" pos:end="229:16">default:</default>

            <expr_stmt pos:start="231:13" pos:end="231:20"><expr pos:start="231:13" pos:end="231:19"><call pos:start="231:13" pos:end="231:19"><name pos:start="231:13" pos:end="231:17">abort</name><argument_list pos:start="231:18" pos:end="231:19">()</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></switch>

        <expr_stmt pos:start="235:9" pos:end="235:27"><expr pos:start="235:9" pos:end="235:26"><call pos:start="235:9" pos:end="235:26"><name pos:start="235:9" pos:end="235:14">assert</name><argument_list pos:start="235:15" pos:end="235:26">(<argument pos:start="235:16" pos:end="235:25"><expr pos:start="235:16" pos:end="235:25"><name pos:start="235:16" pos:end="235:25">io_sectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt pos:start="237:9" pos:end="237:33"><expr pos:start="237:9" pos:end="237:32"><name pos:start="237:9" pos:end="237:18">sector_num</name> <operator pos:start="237:20" pos:end="237:21">+=</operator> <name pos:start="237:23" pos:end="237:32">io_sectors</name></expr>;</expr_stmt>

        <expr_stmt pos:start="239:9" pos:end="239:65"><expr pos:start="239:9" pos:end="239:64"><name pos:start="239:9" pos:end="239:17">nb_chunks</name> <operator pos:start="239:19" pos:end="239:20">-=</operator> <call pos:start="239:22" pos:end="239:64"><name pos:start="239:22" pos:end="239:33">DIV_ROUND_UP</name><argument_list pos:start="239:34" pos:end="239:64">(<argument pos:start="239:35" pos:end="239:44"><expr pos:start="239:35" pos:end="239:44"><name pos:start="239:35" pos:end="239:44">io_sectors</name></expr></argument>, <argument pos:start="239:47" pos:end="239:63"><expr pos:start="239:47" pos:end="239:63"><name pos:start="239:47" pos:end="239:63">sectors_per_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt pos:start="241:9" pos:end="245:9"><if pos:start="241:9" pos:end="245:9">if <condition pos:start="241:12" pos:end="241:28">(<expr pos:start="241:13" pos:end="241:27"><name pos:start="241:13" pos:end="241:27"><name pos:start="241:13" pos:end="241:13">s</name><operator pos:start="241:14" pos:end="241:15">-&gt;</operator><name pos:start="241:16" pos:end="241:21">common</name><operator pos:start="241:22" pos:end="241:22">.</operator><name pos:start="241:23" pos:end="241:27">speed</name></name></expr>)</condition> <block pos:start="241:30" pos:end="245:9">{<block_content pos:start="243:13" pos:end="243:77">

            <expr_stmt pos:start="243:13" pos:end="243:77"><expr pos:start="243:13" pos:end="243:76"><name pos:start="243:13" pos:end="243:20">delay_ns</name> <operator pos:start="243:22" pos:end="243:22">=</operator> <call pos:start="243:24" pos:end="243:76"><name pos:start="243:24" pos:end="243:48">ratelimit_calculate_delay</name><argument_list pos:start="243:49" pos:end="243:76">(<argument pos:start="243:50" pos:end="243:58"><expr pos:start="243:50" pos:end="243:58"><operator pos:start="243:50" pos:end="243:50">&amp;</operator><name pos:start="243:51" pos:end="243:58"><name pos:start="243:51" pos:end="243:51">s</name><operator pos:start="243:52" pos:end="243:53">-&gt;</operator><name pos:start="243:54" pos:end="243:58">limit</name></name></expr></argument>, <argument pos:start="243:61" pos:end="243:75"><expr pos:start="243:61" pos:end="243:75"><name pos:start="243:61" pos:end="243:75">io_sectors_acct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>

    </block_content>}</block></while>

    <return pos:start="249:5" pos:end="249:20">return <expr pos:start="249:12" pos:end="249:19"><name pos:start="249:12" pos:end="249:19">delay_ns</name></expr>;</return>

</block_content>}</block></function>
</unit>
